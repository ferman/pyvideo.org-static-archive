<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>pyvideo.org: Videos of Vivek Sarkar</title><link>http://www.pyvideo.org/speaker/595/vivek-sarkar/rss</link><description></description><atom:link href="http://www.pyvideo.org/speaker/595/vivek-sarkar/rss" rel="self"></atom:link><language>en-us</language><lastBuildDate>Wed, 18 Jul 2012 00:00:00 -0500</lastBuildDate><ttl>500</ttl><item><title>Implicit Multicore Parallelism using CnC-Python</title><link>http://www.pyvideo.org/video/1212/implicit-multicore-parallelism-using-cnc-python</link><description>&lt;p&gt;Description&lt;/p&gt;
We introduce CnC-Python (CP), an approach to implicit multicore parallelism
for Python programmers based on a high-level macro data-flow programming model
called Concurrent Collections (CnC). With the advent of the multi-core era, it
is clear that improvements in application performance will primarily come from
increased parallelism. Extracting parallelism from applications often involves
the use of low-level primitives such as locks and threads. CP is implicitly
parallel and enables programmers to achieve task, data and pipeline
parallelism in a declarative fashion while only being required to describe the
program as a coordination graph with serial Python code for individual nodes
(steps). Thus, CP makes parallel programming accessible to a broad class of
programmers who are not trained in parallel programming. The CP runtime
requires that Python objects communicated between steps be picklable, but
imposes no restriction on the Python idioms used within the serial code. Most
data structures of interest to the SciPy community, including NumPy arrays,
are included in the class of picklable data structures in Python.

The CnC model is especially effective in exploiting parallelism in scientific
applications in which the dependences can be represented as arbitrary directed
acyclic graphs ("dag parallelism"). Such applications include, but are not
limited to, tiled implementations of iterative linear algebra algorithms such
as Cholesky decomposition, Gauss-Jordan elimination, Jacobi method, and
Successive Over-Relaxation (SOR). Rather than using explicit threads and locks
to exploit parallelism, the CnC-Python programmer decomposes their algorithm
into individual computation steps and identifies data and control dependences
among the steps to create such computation DAGs. Given the DAG (in the form of
declarative constraints), it is the responsibility of the CP runtime to
extract parallelism and performance from the application. By liberating the
scientific programmer, who is not necessarily trained to write explicitly
parallel programs, from the nuances of parallel programming, CP provides a
high-productivity path for scientific programmers to achieve multi-core
parallelism in Python.

LINKS: CnC-Python: [http://cnc-python.rice.edu](http://cnc-python.rice.edu)
Concurrent Collections:
[http://habanero.rice.edu/cnc](http://habanero.rice.edu/cnc)

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Shams Imam,Vivek Sarkar</dc:creator><pubDate>Wed, 18 Jul 2012 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/1212/implicit-multicore-parallelism-using-cnc-python</guid><enclosure url="http://s3.us.archive.org/nextdayvideo/enthought/scipy_2012/Implicit_Multicore_Parallelism_using_CnCPython.mp4?Signature=yyqfWPhoAeEggj1Sg1RiEE6k5jQ%3D&amp;Expires=1346381702&amp;AWSAccessKeyId=FEWGReWX3QbNk0h3" length="None" type="video/mp4"></enclosure><media:group><media:content url="http://s3.us.archive.org/nextdayvideo/enthought/scipy_2012/Implicit_Multicore_Parallelism_using_CnCPython.mp4?Signature=yyqfWPhoAeEggj1Sg1RiEE6k5jQ%3D&amp;Expires=1346381702&amp;AWSAccessKeyId=FEWGReWX3QbNk0h3" mime_type="video/mp4"></media:content><media:content url="http://youtube.com/watch?v=ZC2pm2b_Sks" mime_type="video/flv"></media:content></media:group><media:thumbnail url="http://i3.ytimg.com/vi/ZC2pm2b_Sks/hqdefault.jpg"></media:thumbnail></item></channel></rss>