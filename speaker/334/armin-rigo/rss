<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>pyvideo.org: Videos of Armin Rigo</title><link>http://www.pyvideo.org/speaker/334/armin-rigo/rss</link><description></description><atom:link href="http://www.pyvideo.org/speaker/334/armin-rigo/rss" rel="self"></atom:link><language>en-us</language><lastBuildDate>Wed, 23 Jul 2014 00:00:00 -0500</lastBuildDate><ttl>500</ttl><item><title>Using All These Cores: Transactional Memory in PyPy</title><link>http://www.pyvideo.org/video/3006/using-all-these-cores-transactional-memory-in-py</link><description>&lt;p&gt;Abstract&lt;/p&gt;
PyPy, the Python implementation written in Python, experimentally supports Transactional Memory (TM). The strength of TM is to enable a novel use of multithreading, inheritently safe, and not limited to special use cases like other approaches. This talk will focus on how it works under the hood.
&lt;p&gt;Description&lt;/p&gt;
PyPy is a fast alternative Python implementation.  Software Transactional Memory (STM) is a current academic research topic.  Put the two together --brew for a couple of years-- and we get a version of PyPy that runs on multiple cores, without the infamous Global Interpreter Lock (GIL).

The current research is based on a recent new insight that promises to give really good performance.  The speed of STM is generally measured by two factors: the ability to scale with the number of CPUs, and the amount of overhead when compared with other approaches in a single CPU (in this case, with the regular PyPy with the GIL).  Scaling is not really a problem here, but single-CPU performance is --or used to be. This new approach gives a single-threaded overhead that should be very low, maybe 20%, which would definitely be news for STM systems.  Right now (February 2014) we are still implementing it, so we cannot give final numbers yet, but early results on a small interpreter for a custom language are around 15%.  This looks like a deal-changer for STM.

In the talk, I will describe our progress, hopefully along with real numbers and demos.  I will then dive under the hood of PyPy to give an idea about how it works.  I will conclude with a picture of how the future of multi-threaded programming might looks like, for high-level languages like Python.  I will also mention CPython: how hard (or not) it would be to change the CPython source code to use the same approach.</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Armin Rigo</dc:creator><pubDate>Wed, 23 Jul 2014 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/3006/using-all-these-cores-transactional-memory-in-py</guid><enclosure url="http://www.youtube.com/watch?v=yMyMEsOi8oY" length="None" type="video/flv"></enclosure><media:thumbnail url="http://i.ytimg.com/vi/yMyMEsOi8oY/hqdefault.jpg"></media:thumbnail></item><item><title>Software Transactional Memory with PyPy</title><link>http://www.pyvideo.org/video/3918/software-transactional-memory-with-pypy</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Armin Rigo</dc:creator><pubDate>Thu, 03 Oct 2013 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/3918/software-transactional-memory-with-pypy</guid><enclosure url="http://archive.org/download/pyconza2013-pypy-stm/pyconza2013-pypy-stm.ogv" length="None" type="video/ogg"></enclosure><media:thumbnail url="http://archive.org/download/pyconza2013-pypy-stm/pyconza2013-pypy-stm.thumbs/pyconza2013-pypy-stm_000510.jpg"></media:thumbnail></item><item><title>PyPy without the GIL</title><link>http://www.pyvideo.org/video/1739/pypy-without-the-gil</link><description>&lt;p&gt;Abstract&lt;/p&gt;
PyPy has a version without the Global Interpreter Lock (GIL).  It can run multiple threads concurrently.  But the real benefit is that you have other, new ways of using all your cores.  In this talk I will describe how it is possible (STM) and then focus on some of these new opportunities, e.g. show how we used multiple cores in a single really big program without adding thread locks everywhere.</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Armin Rigo</dc:creator><pubDate>Fri, 15 Mar 2013 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/1739/pypy-without-the-gil</guid><enclosure url="http://s3.us.archive.org/nextdayvideo/psf/pycon2013/PyPy_without_the_GIL.mp4?Signature=KVTyOTkBFyh7X56EKD2W5BHb8cY%3D&amp;Expires=1363659535&amp;AWSAccessKeyId=FEWGReWX3QbNk0h3" length="None" type="video/mp4"></enclosure><media:group><media:content url="http://s3.us.archive.org/nextdayvideo/psf/pycon2013/PyPy_without_the_GIL.mp4?Signature=KVTyOTkBFyh7X56EKD2W5BHb8cY%3D&amp;Expires=1363659535&amp;AWSAccessKeyId=FEWGReWX3QbNk0h3" mime_type="video/mp4"></media:content><media:content url="https://www.youtube.com/watch?v=Q9wf63flICs" mime_type="video/flv"></media:content></media:group><media:thumbnail url="http://i2.ytimg.com/vi/Q9wf63flICs/hqdefault.jpg"></media:thumbnail></item><item><title>PyConZA 2012: PyPy</title><link>http://www.pyvideo.org/video/3894/pyconza-2012-pypy</link><description>&lt;p&gt;Abstract&lt;/p&gt;
PyPy: Armin Rigo's talk at PyConZA 2012</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Armin Rigo</dc:creator><pubDate>Thu, 04 Oct 2012 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/3894/pyconza-2012-pypy</guid><enclosure url="http://archive.org/download/pyconza2012-pypy/pyconza2012-pypy.ogv" length="None" type="video/ogg"></enclosure><media:thumbnail url="http://archive.org/download/pyconza2012-pypy/pyconza2012-pypy.thumbs/PYCONZ-BALTIC-ARMINR-PYPY-00_000001.jpg"></media:thumbnail></item><item><title>The story of stackless Python</title><link>http://www.pyvideo.org/video/1307/the-story-of-stackless-python</link><description>&lt;p&gt;Abstract&lt;/p&gt;
[EuroPython 2012] C Tismet A Rigo - 4 JULY 2012 in "Track Spaghetti"


&lt;p&gt;Description&lt;/p&gt;
This talk gives a good overview of the status of Stackless Python: Its history
from the beginning, its current status and its future development to be
expected. A discussion and comparison with similar approaches like Greenlet,
Eventlet and how they relate is also included. Stackless Python 1.0 was
started in 1998 as an implementation of true continuations, with all implied
complications. In 2002, Stackless 2.0 was born, a complete rewrite.
Continuations were abandoned in favor of the much easier to comprehend
tasklets - one-shot continuations that could resume their current state just
once, like Coroutines. In 2004, Stackless 3.0 was created, which merged the
2.0 features with a new concept: so-called “Soft-Switching”, which made the
Pickling of Program State” possible. As a consequence, a few recent
application make solely use of Program State Pickling, which changes the
purpose of Stackless Python quite a bit. One example of this is the “Nagare
Web Framework” which will be shown in examples. In the light of the popularity
of a Stackless spin-off, called “Greenlet”, the concept of a new Stackless
branch will be depicted: Stackless, written as a pure extension module on top
of Greenlets, which includes State Pickling - a feature that seemed to be
impossible to implement without changing CPython. But the impossible and ways
to get around it was always a major topic in this project, which is going to
augment what Stackless on PyPy already can do. Christian Tismer, creator of
Stackless Python Perhaps with Armin Rigo as a guest, talking about Stackless
status in PyPy. Otherwise, I will insert this myself. cheers – Chris

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Armin Rigo,C Tismet</dc:creator><pubDate>Thu, 05 Jul 2012 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/1307/the-story-of-stackless-python</guid><enclosure url="http://www.youtube.com/watch?v=pDkrkP0yf70" length="None" type="video/flv"></enclosure><media:thumbnail url="http://i.ytimg.com/vi/pDkrkP0yf70/hqdefault.jpg"></media:thumbnail></item><item><title>Pypy: current status and gil-less future</title><link>http://www.pyvideo.org/video/1340/pypy-current-status-and-gil-less-future</link><description>&lt;p&gt;Abstract&lt;/p&gt;
[EuroPython 2012] A. Rigo, A. Cuni, M. Fijalkowski - 2 JULY 2012 in "Track
Spaghetti"


&lt;p&gt;Description&lt;/p&gt;
In the first part of the keynote we will present the current status of PyPy,
with a particular focus on what happened in the last year. We will give a
brief overview of the current speed and the on-going development efforts. The
second part of the keynote is about one particular feature whose development
is in progress in PyPy: Automatic Mutual Exclusion. What it is needs some
explanation: The GIL, or Global Interpreter Lock, is a well-known issue for
Python programmers that want to have a single program using the multiple cores
of today’s machines. This keynote is not about writing a GIL-less Python
interpreter; although hard, this has been done before, notably in Jython. The
real issue is that writing each and every multi-threaded Python programs is
hard too. The threading module offers locks in several variants, conditions,
events, semaphores… But using them correctly without missing one case is
difficult, impossible to seriously test, often impossible to retrofit into
existing programs, and arguably doesn’t scale. (Other solutions like the
multiprocessing module are at best workarounds, suffering some of the same
issues plus their own ones.) Instead, this keynote is about an alternate
solution: a minimal thread-less API that lets programs use multiple cores,
without worrying about races. This may sound impossible, but is in fact
similar to the API simplification of using a garbage collected language over
an explicitly managed one — what is not minimal is “just” the internal
implementation of that API. I will explain how it can actually be done using
Automatic Mutual Exclusion, a technique based on Transactional Memory. I will
give preliminary results on a modified version of the PyPy Python interpreter
that show that it can actually work. I will also explain how the API is used,
e.g. in a modified Twisted reactor that gives multi-core capability to any
existing, non-thread-based Twisted program.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">A Cuni,Armin Rigo,M Fijalkowski</dc:creator><pubDate>Wed, 04 Jul 2012 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/1340/pypy-current-status-and-gil-less-future</guid><enclosure url="http://www.youtube.com/watch?v=x6OL88pzjHQ" length="None" type="video/flv"></enclosure><media:thumbnail url="http://i.ytimg.com/vi/x6OL88pzjHQ/hqdefault.jpg"></media:thumbnail></item><item><title>PyPy JIT under the hood</title><link>http://www.pyvideo.org/video/1312/pypy-jit-under-the-hood</link><description>&lt;p&gt;Abstract&lt;/p&gt;
[EuroPython 2012] A Rigo - A Cuni - 4 JULY 2012 in "Track Spaghetti"


&lt;p&gt;Description&lt;/p&gt;
PyPy is probably the fastest Python implementation around, thanks to its
automatically generated JIT compiler. This talk explains how the JIT works
internally: in particular, it shows all the intermediate steps which lead to
the compilation of the Python source into fast machine code, and how to use
the right tools to inspect the output of the JIT compiler. By examining the
internals of the JIT, you will also learn why some code is more “JIT friendly”
than other, and how to write programs which exploits its full potential.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">A Cuni,Armin Rigo</dc:creator><pubDate>Wed, 04 Jul 2012 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/1312/pypy-jit-under-the-hood</guid><enclosure url="http://www.youtube.com/watch?v=cMtBUvORCfU" length="None" type="video/flv"></enclosure><media:thumbnail url="http://i.ytimg.com/vi/cMtBUvORCfU/hqdefault.jpg"></media:thumbnail></item><item><title>Why PyPy by example</title><link>http://www.pyvideo.org/video/661/why-pypy-by-example</link><description>&lt;p&gt;Abstract&lt;/p&gt;
One of the goals of PyPy is to make existing Python code faster, however an
even broader goal was to make it possible to write things in Python that
previous would needed to be written in C or other low-level language. This
talk will show examples of this, and describe how they represent the
tremendous progress PyPy has made, and what it means for people looking to use
PyPy.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Gaynor,Armin Rigo,Maciej Fijalkowski</dc:creator><pubDate>Sat, 10 Mar 2012 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/661/why-pypy-by-example</guid><enclosure url="https://www.youtube.com/watch?v=P5ad6NpjR3M" length="None" type="video/flv"></enclosure><media:thumbnail url="http://img.youtube.com/vi/P5ad6NpjR3M/hqdefault.jpg"></media:thumbnail></item><item><title>How to get the most out of your PyPy</title><link>http://www.pyvideo.org/video/612/how-to-get-the-most-out-of-your-pypy</link><description>&lt;p&gt;Abstract&lt;/p&gt;
For many applications PyPy can provide performance benefits right out of the
box. However, little details can push your application to perform much better.
In this tutorial we'll give you insights on how to push pypy to it's limites.
We'll focus on understanding the performance characteristics of PyPy, and
learning the analysis tools in order to maximize your applications
performance.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Gaynor,Armin Rigo,Maciej Fijalkowski</dc:creator><pubDate>Wed, 07 Mar 2012 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/612/how-to-get-the-most-out-of-your-pypy</guid><enclosure url="https://www.youtube.com/watch?v=oZw8m_lyhvo" length="None" type="video/flv"></enclosure><media:thumbnail url="http://img.youtube.com/vi/oZw8m_lyhvo/hqdefault.jpg"></media:thumbnail></item><item><title>PyPy hands-on</title><link>http://www.pyvideo.org/video/1037/pypy-hands-on</link><description>&lt;p&gt;Abstract&lt;/p&gt;
[EuroPython 2011] Antonio Cuni,Armin Rigo - 21 June 2011 in "Training Pizza
Margherita"


&lt;p&gt;Description&lt;/p&gt;
The session is divided into two parts, of roughly 2 hours each. People who are
interested only in the first part, can leave the session after it. However,
the first part is a prerequisite for the second one, thus people are not
advised to join in the middle of the session.

The session is meant to be highly interactive. People are invited to bring
their own laptop and try things by themselves.

## Part 1: Run your application under PyPy

This tutorial is targeted to Python users who want to run their favorite
Python application under PyPy, and exploit the most of it. The following
topics will be covered:

    
    - how to fix/avoid CPython implementation details (e.g., refcounting)
    
    - general overview of how the PyPy JIT works
    
    - how to optimize your program for the PyPy JIT
    
    - how to view and interpret the traces produced by the JIT
    
    - how to tweak the parameters of the JIT and the GC
    
    - how to use existing CPython C extensions on PyPy, and fix them if necessary
    

## Part 2: Write your own interpreter with PyPy

PyPy is not only a Python interpreter, but also a toolchain to implement
dynamic languages. This tutorial is targeted to people who want to implement
their own programming languages, or who simply want to know more about how the
PyPy JIT works internally.

The students will be given the source code for a toy language implemented in
RPython. They will learn:

    
    - how to translate it to C using the PyPy translation toolchain
    
    - what are the "hints" needed by the JIT generator, and how to place them
    

Then, they will be challenged to add the proper hints to the toy interpreter,
to get the best result with the JIT.

**THINGS TO DO BEFORE THE TRAINING**

You are encouraged to bring your laptop to the training session.

Make sure that the following prerequisites are met:

  * Install PyPy 1.5:

    * [http://pypy.org/download.html](http://pypy.org/download.html)

    * [http://doc.pypy.org/en/latest/getting-started.html#installing-pypy](http://doc.pypy.org/en/latest/getting-started.html#installing-pypy)

  * Make sure that `setuptools` or `distribute` are installed (look at the URL above for instructions)

  * Clone the pypy repository, and update to the 1.5 version::

$ hg clone [http://bitbucket.org/pypy/pypy](http://bitbucket.org/pypy/pypy)

$ cd pypy

$ hg up -r release-1.5

  * Clone the jitviewer repository and install it on pypy::

$ hg clone
[http://bitbucket.org/pypy/jitviewer](http://bitbucket.org/pypy/jitviewer)

$ cd jitviewer

$ /path/to/pypy-1.5/bin/pypy setup.py develop

If you intend to follow also the second part ("Write your own interpreter with
PyPy"), you need to make sure you have a working [developing
environment](http://doc.pypy.org/en/latest/getting-started-python.html
#translating-the-pypy-python-interpreter)

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Antonio Cuni,Armin Rigo</dc:creator><pubDate>Thu, 21 Jul 2011 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/1037/pypy-hands-on</guid><enclosure url="http://www.youtube.com/watch?v=qcqEAE4QoeA" length="None" type="video/flv"></enclosure><media:thumbnail url="http://i.ytimg.com/vi/qcqEAE4QoeA/hqdefault.jpg"></media:thumbnail></item><item><title>PyPy hands-on</title><link>http://www.pyvideo.org/video/1067/pypy-hands-on-0</link><description>&lt;p&gt;Abstract&lt;/p&gt;
[EuroPython 2011] Antonio Cuni,Armin Rigo - 21 June 2011 in "Training Pizza
Margherita"


&lt;p&gt;Description&lt;/p&gt;
The session is divided into two parts, of roughly 2 hours each. People who are
interested only in the first part, can leave the session after it. However,
the first part is a prerequisite for the second one, thus people are not
advised to join in the middle of the session.

The session is meant to be highly interactive. People are invited to bring
their own laptop and try things by themselves.

## Part 1: Run your application under PyPy

This tutorial is targeted to Python users who want to run their favorite
Python application under PyPy, and exploit the most of it. The following
topics will be covered:

    
    - how to fix/avoid CPython implementation details (e.g., refcounting)
    
    - general overview of how the PyPy JIT works
    
    - how to optimize your program for the PyPy JIT
    
    - how to view and interpret the traces produced by the JIT
    
    - how to tweak the parameters of the JIT and the GC
    
    - how to use existing CPython C extensions on PyPy, and fix them if necessary
    

## Part 2: Write your own interpreter with PyPy

PyPy is not only a Python interpreter, but also a toolchain to implement
dynamic languages. This tutorial is targeted to people who want to implement
their own programming languages, or who simply want to know more about how the
PyPy JIT works internally.

The students will be given the source code for a toy language implemented in
RPython. They will learn:

    
    - how to translate it to C using the PyPy translation toolchain
    
    - what are the "hints" needed by the JIT generator, and how to place them
    

Then, they will be challenged to add the proper hints to the toy interpreter,
to get the best result with the JIT.

**THINGS TO DO BEFORE THE TRAINING**

You are encouraged to bring your laptop to the training session.

Make sure that the following prerequisites are met:

  * Install PyPy 1.5:

    * [http://pypy.org/download.html](http://pypy.org/download.html)

    * [http://doc.pypy.org/en/latest/getting-started.html#installing-pypy](http://doc.pypy.org/en/latest/getting-started.html#installing-pypy)

  * Make sure that `setuptools` or `distribute` are installed (look at the URL above for instructions)

  * Clone the pypy repository, and update to the 1.5 version::

$ hg clone [http://bitbucket.org/pypy/pypy](http://bitbucket.org/pypy/pypy)

$ cd pypy

$ hg up -r release-1.5

  * Clone the jitviewer repository and install it on pypy::

$ hg clone
[http://bitbucket.org/pypy/jitviewer](http://bitbucket.org/pypy/jitviewer)

$ cd jitviewer

$ /path/to/pypy-1.5/bin/pypy setup.py develop

If you intend to follow also the second part ("Write your own interpreter with
PyPy"), you need to make sure you have a working [developing
environment](http://doc.pypy.org/en/latest/getting-started-python.html
#translating-the-pypy-python-interpreter)

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Antonio Cuni,Armin Rigo</dc:creator><pubDate>Mon, 18 Jul 2011 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/1067/pypy-hands-on-0</guid><enclosure url="http://www.youtube.com/watch?v=J1ZTPi06awk" length="None" type="video/flv"></enclosure><media:thumbnail url="http://i.ytimg.com/vi/J1ZTPi06awk/hqdefault.jpg"></media:thumbnail></item><item><title>PyPy in production</title><link>http://www.pyvideo.org/video/1113/pypy-in-production</link><description>&lt;p&gt;Abstract&lt;/p&gt;
[EuroPython 2011] Antonio Cuni,Armin Rigo - 23 June 2011 in "Track Lasagne"


&lt;p&gt;Description&lt;/p&gt;
The PyPy project has recently gathered a lot of attention for its progress in
speeding up the Python language - it is the fastest Python interpreter, and
the most compatible and most stable 'alternative´ one. No longer merely a
research project, PyPy is now suitable for production use. We are working on
improvements on calling into C libraries and generally integrating with the
existing Python extensions ecosystem.

We will give an overview on how the tracing Just-in-Time compiler works in
PyPy. From there, we will then focus on what the PyPy project has achieved,
particularly in the past two years:

  * most Python benchmarks run much faster than with CPython or Psyco

  * the real-world PyPy compiler toolchain itself (200 KLocs) runs twice as fast

  * already supports 32 and 64bit x86 and is in the process of supporting ARM

  * full compatibility with CPython (more than Jython/IronPython)

  * full (and JIT-ed) ctypes support to call C libraries from Python

  * supports Stackless Python (in-progress)

  * new "cpyext" layer which integrates existing CPython C extensions

  * an experimental super-fast JIT-compilation of calls to C++ libraries

We want to reserve time for discussing potential future work like SWIG and/or
Cython compatibility and other areas brought up by the audience. There are
many interesting details that can be explored further; we will focus on the
points the audience is most interested in.

For more info:

  * [http://pypy.org/](http://pypy.org/)

  * Our blog: [http://morepypy.blogspot.com/](http://morepypy.blogspot.com/)

  * Eureka program: [http://www.eurostars-eureka.eu/](http://www.eurostars-eureka.eu/)

_Eurostars Eureka is our funding source since 2009. It is a cross-European
funding collaboration that targets small firms which produce research._

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Antonio Cuni,Armin Rigo</dc:creator><pubDate>Wed, 13 Jul 2011 00:00:00 -0500</pubDate><guid>http://www.pyvideo.org/video/1113/pypy-in-production</guid><enclosure url="http://www.youtube.com/watch?v=nTpte3_jNO0" length="None" type="video/flv"></enclosure><media:thumbnail url="http://i.ytimg.com/vi/nTpte3_jNO0/hqdefault.jpg"></media:thumbnail></item></channel></rss>