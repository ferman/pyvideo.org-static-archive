{"category": "EuroPython 2014", "language": "English", "slug": "post-mortem-debugging-with-heap-dumps", "speakers": ["Anselm Kruis"], "tags": [], "related_urls": [], "id": 2935, "state": 1, "title": "Post-Mortem Debugging with Heap-Dumps", "summary": "UNIX core-dumps, Windows minidumps or Java heap-dumps are well established technologies for post-mortem defect analysis.\r\nI'll present a similar technology for Python. An improved pickling mechanism makes it possible to serialise the state of a Python \r\nprogram for subsequent analysis with a conventional Python-debugger.", "description": "Post-Mortem Debugging with Heap-Dumps\r\n=====================================\r\n\r\nUNIX core-dumps, Windows minidumps and analogous solutions of other operating systems are well established technologies for \r\npost-mortem defect analysis of native-code processes. In principle those dumps can be used to analyse \u201einterpreted\u201c \r\nprograms running within a native-code interpreter-process. However in practise this approach is tedious and not always successful \\[1\\].\r\nTherefore operating system independent dump methods were developed for some \u201einterpreted\u201c languages \\[2\\]. \r\nA prominent example are Java heap dumps \\[3\\]. \r\n\r\nUnfortunately up to now there was no practically usable dump-method for Python. Various attempts were made \r\nto utilise OS-level dump methods \\[4, 5\\]. In 2012 Eli Finer published the Python module *pydump* \\[6\\].\r\nThis module pickles the traceback of an exception and subsequently uses the pdb debugger to analyse the unpickled traceback.\r\nUnfortunately *pydump* fails on PicklingErrors.\r\n\r\nIn my talk I'll present the Python package [*pyheapdump*](https://pypi.python.org/pypi/pyheapdump). It has the same operation principle as Eli's *pydump*, but \r\nis an independent implementation. *pyheapdump* uses an extended pickler \r\n([sPickle](https://pypi.python.org/pypi/sPickle)) to serialise all relevant objects \r\nof a Python process to a file. Later on a fault tolerant unpickler recreates the objects and a common Python\r\ndebugger can be used to analyse the dump. The pickler extensions make it possible to:\r\n\r\n * pickle and unpickle many commonly not pickleable objects [7].\r\n * replace the remaining not pickleable objects by surrogate objects so that the resulting object graph is\r\n   almost isomorphic to the original object graph.\r\n   \r\nWhich objects are relevant? In its default operation mode *pyheapdump* \r\nuses the frame-stacks of all threads as start point for pickling. Following the \r\nusual rules for pickling the dump includes all local variables and all objects \r\nreachable from a local variable and so on. That is usually enough for a successful defect analysis.\r\n\r\nCompared with other Python post-mortem debugging methods *pyheapdump* has several advantages:\r\n\r\n * It is a pure Python solution and independent from the operation system.\r\n * Creation of the pyheapdump and fault analysis can be performed different computers.\r\n * It is not obstructive. It does not modify / monkey-patch or disturb the dumped \r\n   process in any way, with the exception of loading additional modules.\r\n * If used with the Pydev-debugger, it supports multi-threaded applications.\r\n * If used with the Pydev-debugger and Stackless Python, it supports tasklets. \r\n\r\nThe implementation of *pyheapdump* is fairly small, because it draws most of its functionality \r\nfrom the underlying sPickle package and from the new Stackless-Support \\[8\\] of the\r\nPydev-Debugger. Therefore it is - despite of its short history - already a useful piece of software.\r\n\r\nOutline of the talk\r\n-------------------\r\n\r\n1.\tIntroduction to the problem\r\n2.\tPrevious works\r\n3.\tThe concept of *pyheapdump*\r\n4.\tLive demonstration\r\n5.\tOpen problems and further development\r\n6.\tQuestions and Answers\r\n\r\nReferences\r\n----------\r\n\r\n1. Andraz Tori, Python, 2011-01-16: *gdb and a very large core dump*, blog at <http://www.zemanta.com/blog/python-gdb-large-core-dump/>\r\n2. David Pacheco, ACM Queue - Programming Languages Volume 9 Issue 10, October 2011: \r\n   *Postmortem Debugging in Dynamic Environments*, \r\n   PDF <http://dl.acm.org/ft_gateway.cfm?id=2039361&ftid=1050739&dwn=1&CFID=290171300&CFTOKEN=95099236>\r\n3. Chris Bailey, Andrew Johnson, Kevin Grigorenko, IBM developerWorks, 2011-03-15: \r\n   *Debugging from dumps - Diagnose more than memory leaks with Memory Analyzer*, \r\n   PDF <http://www.ibm.com/developerworks/library/j-memoryanalyzer/j-memoryanalyzer-pdf.pdf>\r\n4. Brian Curtin, 2011-09-29: *minidumper - Python crash dumps on Windows*, \r\n   blog at <http://blog.briancurtin.com/posts/20110929minidumper-python-crash-dumps-on-windows.html>\r\n5. David Malcolm, Fedora Feature, 2010-04-06: *Easier Python Debugging* \r\n   at <http://fedoraproject.org/wiki/Features/EasierPythonDebugging>\r\n6. Eli Finer, Github-Project, 2012: *pydump* at <https://github.com/gooli/pydump>\r\n7. Anselm Kruis, EuroPython 2011: *Advanced Pickling with Stackless Python and sPickle*,\r\n   archived talk at <https://ep2013.europython.eu/conference/talks/advanced-pickling-with-stackless-python-and-spickle>\r\n8. Fabio Zadrozny, 2013-12-12: *PyDev 3.1.0 released*, \r\n   blog at <http://pydev.blogspot.de/2013/12/pydev-310-released.html>\r\n\r\n", "quality_notes": "", "copyright_text": "http://creativecommons.org/licenses/by/3.0/", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/0Xt-au2QnRg?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/0Xt-au2QnRg?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i.ytimg.com/vi/0Xt-au2QnRg/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=0Xt-au2QnRg", "whiteboard": "", "recorded": "2014-07-25", "added": "2014-07-31T00:46:23.566", "updated": "2014-07-31T01:04:31.601"}