{"category": "EuroPython 2014", "language": "English", "slug": "mobile-games-to-the-cloud-with-python", "speakers": ["Darko Roni\u0107", "Mislav Stipetic"], "tags": [], "related_urls": [], "id": 3041, "state": 1, "title": "Mobile Games to the Cloud With Python", "summary": "When a mobile game development company decides to switch to a more cloud based development it is faced with obstacles different from those it's used to on mobile devices. This talk explains how Python provided us with most of the infrastructure for this task and how a Python game backend was built as a result.", "description": "#### The Talk\r\n\r\nThis talk has two goals. Showing the audience the lessons we learned during a project which moved a simple mobile game to a server backend is our first intention. In addition to that we want to describe how such a system works in a real life example, to show which problems and which requirements arise in its creation. When the audience leaves the talk they will know how a real-life mobile game uses Python for powering the backend servers.\r\n\r\n \r\n#### The Problem\r\n\r\nMost of the game development for mobile devices is focused on running the game on the device. The game designers and game developers play a primary role in creating the product. The server backend plays a supporting role providing a multiplayer or social experience to the users. Indeed, at Nanobit Ltd., things were also done that way. We had a small Python infrastructure built around Django which provided a small portion of multiplayer experience for the players. The majority of development was still focused on playing the game on the device. That way of thinking was put to test when we decided to center our future games around the multiplayer experience. Due to the fact that our infrastructure at the time was not enough for what we had in mind, we had to start from scratch. The decision was made to use Python as the center of our new infrastructure.\r\n\r\nIn order to achieve it, a server backend was needed that would allow the game to be played \u201cin the cloud\u201d with the device only being a terminal to the player. Most of the game logic would have to be processed in the cloud which meant that each player required a constant connection to the backend and with over 100.000 players in our previous games that presented a challenge. How to build an infrastructure which can support that? Since every user action had to be sent to the backend how to process thousands of them quick enough? Those problems were big and were just the start.\r\n\r\n\r\n#### The Solution\r\n\r\nThe design of the backend lasted for a couple of months and produced a scalable infrastructure based on \u201cworkers\u201d developed in Python, \u201cweb servers\u201d that use Tornado and a custom message queue which connected the two. The storage part is a combination of Riak and Redis. Since the backend is scalable new workers and new web servers had to be deployed easily so an orchestration module was build using Fabric. The scalability and launching of new workers and web servers was achieved using Docker for creation and deployment of containers. Each container presents one module of the system (worker, web server, queue). The end result can now support all of our future games and only requires the game logic of each game to be added to the workers.\r\n\r\n\r\n#### The Technologies\r\n\r\n* Python for coding the game logic, web servers. More than 90% of the system was written in Python.\r\n* Fabric\r\n* SQLAlchemy\r\n* Riak\r\n* Redis\r\n* ZeroMQ\r\n* nginx\r\n* Docker\r\n* Websockets\r\n* AWS\r\n\r\n\r\n#### The Lessons Learned\r\n\r\n* How to tune the backend to handle the increasing number of active players.\r\n* How to tackle the problem of frequent connection dropping and reachability issues of poor mobile device Internet connection in Tornado with a little help of Redis.\r\n* How to prevent users from trying to outsmart the system by denying illegal moves.\r\n* How to enable game profile syncing and live updating.\r\n* Improving the performance of workers by prioritizing data being stored to databases (Riak, SQL).\r\n* New issues and lessons show up all the time so there will definitely be more of them by the time of the conference.\r\n\r\n\r\n#### Basic Outline\r\n\r\n1. Intro (5 min)\r\n    1. Who are we?\r\n    2. How was Python used in our previous games\r\n    3. Why we decided to change it all\r\n2. Requirements (6 min)\r\n    1. What was the goal of creating the game backend\r\n    2. Why was Python our first choice\r\n3. Python backend (14 min)\r\n    1. The architecture of the backend\r\n    2. Which technologies did we use and how were they connected together\r\n    3. How the backend handles the game logic\r\n    4. Lessons learned\r\n4. Questions & Answers (5 min)", "quality_notes": "", "copyright_text": "http://creativecommons.org/licenses/by/3.0/", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/wWypp2KexGs?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/wWypp2KexGs?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i.ytimg.com/vi/wWypp2KexGs/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=wWypp2KexGs", "whiteboard": "", "recorded": "2014-07-22", "added": "2014-07-31T00:46:35.339", "updated": "2014-08-02T11:26:25.174"}