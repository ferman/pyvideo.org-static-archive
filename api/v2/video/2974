{"category": "EuroPython 2014", "language": "English", "slug": "support-python-2-and-3-with-the-same-code", "speakers": ["Stefan Schwarzer"], "tags": [], "related_urls": [], "id": 2974, "state": 1, "title": "Support Python 2 and 3 with the same code", "summary": "Your library supports only Python 2, - but your users keep nagging you about Python 3 support?\r\n\r\nAs Python 3 gets adopted more and more, users ask for Python 3 support in existing libraries for Python 2. Although there are several approaches, this talk focuses on using the very same code for a Python 2 and a Python 3 version.\r\n\r\nThe talk discusses the main problems when supporting Python 3 and best practices to apply for compatibility with Python 2 and 3.", "description": "Your library supports only Python 2, - but your users keep nagging you about Python 3 support?\r\n\r\nAs Python 3 gets adopted more and more, users ask for Python 3 support in existing libraries for Python 2. This talk mentions some approaches for giving users a Python 3 version, but will quickly focus on using the very same code for a Python 2 and a Python 3 version.\r\n\r\nThis is much easier if you require Python 2.6 and up, and yet a bit easier if you require Python 3.3 as the minimum Python 3 version.\r\n\r\nThe talk discusses main problems when supporting Python 3 (some are easily solved):\r\n\r\n* `print` is a function.\r\n\r\n* More Python APIs return iterators that used to return lists.\r\n\r\n* There's now a clear distinction between bytes and unicode (text) strings.\r\n\r\n* Files are opened as text by default, requiring an encoding to apply on reading and writing.\r\n\r\n\r\nThe talk also explains some best practices:\r\n\r\n* Start with a good automatic test coverage.\r\n\r\n* Deal with many automatic conversions with a one-time 2to3 run.\r\n\r\n* Think about how your library should handle bytes and unicode strings. (Rule of thumb: Decode bytes as early as possible; encode unicode text as late as possible.)\r\n\r\n* Should you break compatibility with your existing Python 2 API? (Yes, if there's no other way to design a sane API for Python 2 and 3. If you do it, raise the first part of the version number.)\r\n\r\n* Try to keep code that's different for Python 2 and 3 minimal. Put code that needs to be different for Python 2 and 3 into a `compat` module. Or use third-party libraries like `six` or `future`.\r\n\r\n\r\nFinally, the talk will mention some helpful resources on the web.", "quality_notes": "", "copyright_text": "http://creativecommons.org/licenses/by/3.0/", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/elAV6aZDMvg?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/elAV6aZDMvg?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i.ytimg.com/vi/elAV6aZDMvg/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=elAV6aZDMvg", "whiteboard": "", "recorded": "2014-07-24", "added": "2014-07-31T00:46:27.832", "updated": "2014-07-31T23:05:34.218"}