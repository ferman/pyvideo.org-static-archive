{"category": "SciPy 2014", "language": "English", "slug": "pyviennacl-very-easy-gpgpu-linear-algebra-part-1", "speakers": ["Toby St Clere Smithe"], "tags": ["gpgpu"], "related_urls": [], "id": 2730, "state": 1, "title": "PyViennaCL: Very Easy GPGPU Linear Algebra Part 1", "summary": "PyViennaCL aims to make powerful GPGPU scientific computing really transparently easy, especially for users already using NumPy for representing matrices, by harnessing the ViennaCL linear algebra and numerical computation library for GPGPU and heterogeneous systems. In this talk, I will discuss PyViennaCL's mathematical features, computational architecture, and current developments.", "description": "ViennaCL provides a BLAS-like interface to a set of OpenCL, CUDA and OpenMP compute kernels for linear algebra operations, such as dense and sparse matrix products, direct and iterative solvers, preconditioners. At the C++ API level, ViennaCL uses templates to represent a mathematical expression graph, for which it then generates an appropriate compute kernel.\r\n\r\nInterfacing with a C++ templating API from Python, for which users' expressions are expected to be set at compile time, poses a number of problems for the dynamic creation of objects and execution of arbitrary expressions.  For the Python interface, we have a scheduler which takes an expression tree object constructed in Python (using Boost.Python), and then generates and dispatches the relevant kernel, using the relevant data types for the operands. Furthermore, so that users do not regularly incur expensive copying of matrices across slow system buses, PyViennaCL implements various caching mechanisms. Work is currently in progress to support multiple, heterogeneous and distributed platforms, and custom, user-supplied expression nodes, using PyOpenCL and PyCUDA.\r\n\r\nTo make these features approachable to users familiar with NumPy and SciPy, the PyViennaCL API attempts to be as similar to the NumPy API as possible, providing recognisable classes, methods, and attributes, and transparently converting operand and result types where these things are defined.\r\n\r\nThis talk will introduce PyViennaCL, covering in more detail the computational architecture described above, as well as these Python API features, and the power of upcoming work to extend the PyViennaCL scheduler and API to custom compute operations, by integrating with PyOpenCL and PyCUDA. In the process, I will provide some comparative benchmark results, to demonstrate the utility of this new work.", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/Qym3Onh-Z20?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/Qym3Onh-Z20?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/Qym3Onh-Z20/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=Qym3Onh-Z20", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-09T19:24:55.720", "updated": "2014-07-09T19:24:55.720"}