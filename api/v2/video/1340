{"category": "EuroPython 2012", "language": null, "slug": "pypy-current-status-and-gil-less-future", "speakers": ["A Cuni", "Armin Rigo", "M Fijalkowski"], "tags": [], "related_urls": [], "id": 1340, "state": 1, "title": "Pypy: current status and gil-less future", "summary": "[EuroPython 2012] A. Rigo, A. Cuni, M. Fijalkowski - 2 JULY 2012 in \"Track\nSpaghetti\"\n\n", "description": "In the first part of the keynote we will present the current status of PyPy,\nwith a particular focus on what happened in the last year. We will give a\nbrief overview of the current speed and the on-going development efforts. The\nsecond part of the keynote is about one particular feature whose development\nis in progress in PyPy: Automatic Mutual Exclusion. What it is needs some\nexplanation: The GIL, or Global Interpreter Lock, is a well-known issue for\nPython programmers that want to have a single program using the multiple cores\nof today\u2019s machines. This keynote is not about writing a GIL-less Python\ninterpreter; although hard, this has been done before, notably in Jython. The\nreal issue is that writing each and every multi-threaded Python programs is\nhard too. The threading module offers locks in several variants, conditions,\nevents, semaphores\u2026 But using them correctly without missing one case is\ndifficult, impossible to seriously test, often impossible to retrofit into\nexisting programs, and arguably doesn\u2019t scale. (Other solutions like the\nmultiprocessing module are at best workarounds, suffering some of the same\nissues plus their own ones.) Instead, this keynote is about an alternate\nsolution: a minimal thread-less API that lets programs use multiple cores,\nwithout worrying about races. This may sound impossible, but is in fact\nsimilar to the API simplification of using a garbage collected language over\nan explicitly managed one \u2014 what is not minimal is \u201cjust\u201d the internal\nimplementation of that API. I will explain how it can actually be done using\nAutomatic Mutual Exclusion, a technique based on Transactional Memory. I will\ngive preliminary results on a modified version of the PyPy Python interpreter\nthat show that it can actually work. I will also explain how the API is used,\ne.g. in a modified Twisted reactor that gives multi-core capability to any\nexisting, non-thread-based Twisted program.\n\n", "quality_notes": "", "copyright_text": "Standard YouTube License", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/x6OL88pzjHQ?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/x6OL88pzjHQ?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i.ytimg.com/vi/x6OL88pzjHQ/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=x6OL88pzjHQ", "whiteboard": "", "recorded": "2012-07-04", "added": "2012-09-06T22:33:27", "updated": "2014-04-08T20:28:27.295"}