{"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--testing-the-mobile--and-desktop--web-", "speakers": ["Jason Huggins"], "tags": ["browsers", "embedded", "html5", "pycon", "pycon2011", "selenium", "webdriver"], "related_urls": [], "id": 373, "state": 1, "title": "Testing the Mobile (and Desktop) Web with Selenium 2.0 - Better, Faster, and more Pythonicly", "summary": "", "description": "Testing the Mobile (and Desktop) Web with Selenium 2.0 - Better, Faster, and\nmore Pythonicly\n\nPresented by Jason Huggins\n\nSelenium is a popular web application testing tool for acceptance testing\ndynamic web applications. Selenium 2.0 has a different architecture that makes\nit leaner, meaner, and more pythonic -- for testing desktop *and* mobile web\n(iPhone/Android) apps. This talk will go into detail on how Selenium 2 works.\nIf you like testing and Python, you'll enjoy what's cooking in Selenium 2.\n\nAbstract\n\nSelenium was originally created by Jason Huggins and his team at ThoughtWorks\nin 2004 as a tool for cross-browser acceptance testing of dynamic web apps --\napps that use JavaScript heavily on the client. Over the years, the Selenium\ntool family has expanded to include a Firefox record and playback tool\n(Selenium IDE), a Remote Control server that allows API access from any major\nprogramming language, and a Grid server that allows tests to run in parallel\nacross many machines.\n\nDespite it's widespread industry adoption, the Selenium project is far from\ndone. Selenium's goal is to drive any browser the same way an end user would\n(e.g. opening pages, clicking buttons, entering text, etc.) with any\nprogramming language on any OS platform. It's an ambitious goal, and with a\nsteady stream of new browsers (Chrome), new platforms (Android, iPhone), and\nnew HTML5 technologies (video, canvas, offline storage) to support, just\nkeeping up is an arduous task.\n\nAstute observers will note, though, the bulk of Selenium's automation engine\nis implemented in JavaScript, which is confined by the browser's security\nsandbox in which it executes JavaScript code. That security sandbox ultimately\nis at odds with Selenium's goal to drive the browser just as a user would. A\nuser has no problem interacting with security alerts for untrusted\ncertificates, or file upload dialog boxes, but Selenium can't deal with these\nkinds of things easily without extra effort.\n\nEnter WebDriver. There's a lot in common between the Selenium and WebDriver\nprojects. They're both tools for automated testing of web applications, and\nboth aspire to offer browser test automation from any language on any\nplatform. However, they do their thing in radically different ways. Selenium\nuses the strategy that JavaScript is the one common tool available for\nautomating all browsers, even though its capabilities can be highly\nconstrained. Meanwhile, WebDriver leverages the strategy that acknowledges\ndifferent automation strategies work best for different browsers. COM works\nbest for IE on Windows, Apple Events for Safari on OS X. And Firefox, well,\nthe best way to natively automate Firefox is to turn it into a telnet server.\n(But that's a whole other PyCon talk entirely!) WebDriver aims to natively\ndrive each browser the best way possible for maximum capability, then hiding\nthose differences between lower level C and C++ APIs, and finally exposing the\nfunctionality through the appropriate C/C++ mechanism for each target\nlanguage, such as using ctypes for Python. With WebDriver's technical\napproach, anything a user can do is now possible in test automation code.\n\nThis talk will go into detail explaining how Selenium and WebDriver (aka\nSelenium 2) work, comparing the strengths and weaknesses of each tool's\napproach to browser automation. The talk will then explain what Selenium 2.0\nlooks like and how to use it.\n\nTalk outline:\n\n  * Description of problem space \n    * More browsers \n    * More frequent browser releases \n    * HTML 5 - video, canvas, offline storage \n    * The web in more places - Mobile, Chrome OS \n  * Description of Selenium \n  * Strengths of Selenium \n  * Description of challenges for Selenium 1 \n    * Javascript security sandbox \n    * Same origin policy / cross-site scripting \n    * OS-level popups \n    * Speed / stability \n    * Java as the cross-language integration point (aka Not Very Pythonic, eh?) \n  * Description of Selenium 2 (aka WebDriver) \n  * Strengths of Selenium 2 \n  * How Selenium 2 is more pythonic \n    * (Lots and lots of example code goes here.) \n    * Spoiler Alert: No Java server required! \n  * How to test Android apps \n  * How to test iPhone apps \n  * Selenium development roadmap \n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011TestingTheMobileAndDesktopWebWithSelenium20524.png", "duration": null, "video_ogv_length": 141105384, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/373_testing-the-mobile-and-desktop-web-with-selenium-2-0-better-faster-and-more-pythonicly.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.044"}