<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>pyvideo.org: Videos of PyCon US 2011</title><link>http://www.pyvideo.org/category/7/pycon-us-2011/rss</link><description></description><atom:link href="http://www.pyvideo.org/category/7/pycon-us-2011/rss" rel="self"></atom:link><language>en-us</language><lastBuildDate>Fri, 11 Mar 2011 00:00:00 -0600</lastBuildDate><ttl>500</ttl><item><title>Advanced Network Architectures With ZeroMQ</title><link>http://www.pyvideo.org/video/442/pycon-2011--advanced-network-architectures-with-z</link><description>&lt;p&gt;Description&lt;/p&gt;
Advanced Network Architectures With ZeroMQ

Presented by Zed A. Shaw

In this talk I will demonstrate how to use ZeroMQ with Python (and others) to
do really advanced or even weird network architectures. You'll see Python talk
to other languages, handle HTTP, JSON, XML, WebSockets, encode videos, chat
messaging, etc. All in a short talk with only code, no diagrams. You should
know ZeroMQ already.

Abstract

This talk will demonstrate a series of progressively difficult problems that
you can solve with ZeroMQ:

  1. Basic messaging types (request/response, publish/subscribe). 
  2. Mongrel2 and HTTP processing. 
  3. Coroutine based web frameworks and why they suck (so quit making them). 
  4. Distributed worker queues of various flavors. 
  5. Asynchronous chat protocols with JSON and XML. 
  6. Clusters of calculators considering and communicating. 
  7. Talking to other languages and easily ditching Python if you need. 
  8. Anything else I can think up and do in a single screen of Python. 

This talk will assume you know ZeroMQ and Python, but if you don't know ZeroMQ
you can probably still keep up.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zed A. Shaw</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/442/pycon-2011--advanced-network-architectures-with-z</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/442_advanced-network-architectures-with-zeromq.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011AdvancedNetworkArchitecturesWithZeroMQ366.png"></media:thumbnail></item><item><title>Algorithmic Generation of OpenGL Geometry</title><link>http://www.pyvideo.org/video/381/pycon-2011--algorithmic-generation-of-opengl-geom</link><description>&lt;p&gt;Description&lt;/p&gt;
Algorithmic Generation of OpenGL Geometry

Presented by Jonathan Hartley

Starting from a basic 'hello world' OpenGL app, a simple and Pythonic model of
3D polyhedra is presented, with neat generators to convert these into ctype
arrays for OpenGL. Geometric algorithms then generate some fun geometry, and
these are compounded to produce successively more complex and interesting
shapes.

Abstract

The author's intent is to demonstrate that effective stylistic 3D graphics can
be achieved using surprisingly small amounts of code. This hopefully makes the
topic amenable to 3D beginners, while possibly suggesting some alternative
approaches to those with 3D experience.

Talk Outline

Throughout, discussion of ideas and code dissection alternates with live
animated demos, at 60fps on very modest hardware.

  1. Inspirations - Effective non-photo-realistic work in gaming, movies and the demo scene. (1m) 
  2. A convenient &amp; Pythonic way to model 3D polyhedra, and some neat generators to convert these into OpenGL arrays at runtime. (7m) 
  3. Composition of polyhedra to create more complex shapes. (3m) 
  4. The resulting performance characteristics: What works well from Python, and what doesn't. (2m) 
  5. Koch tetrahedron &amp; tetrix, aka Sierpinski tetrahedron. (1m) 
  6. Surprisingly effective 3D models created from small bitmaps. (1m) 
  7. Automatic generation of trees, mazes, complex spaces. (3m) 
  8. Algorithmic modification of existing shapes, such as bevels, geometric duals, and polyhedron stellation. (2m) 
  9. Shapes that morph: Rearranging vertices on the fly (5m) 
  10. Questions (5m) 

The ideas demonstrated in the talk are written against OpenGL 2.1, but written
in a 'mostly OpenGL 3' style, using vertex buffer objects or vertex arrays.

The demo code uses pyglet to create a window and handle GUI events, and uses
PyOpenGL for the majority of OpenGL calls, since it provides a more friendly
and Pythonic interface. In the performance-sensitive inner render loop,
however, I use pyglet's slightly more bare-bones OpenGL bindings.

However, the majority of the talk focuses on the manipulation of abstract data
structures to represent geometry, which is not affected by these or other
OpenGL library choices.

This is a substantially improved version of the talk 'Flying High: Hobbyist
OpenGL from Python', previously presented at EuroPython 2010.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jonathan Hartley</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/381/pycon-2011--algorithmic-generation-of-opengl-geom</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/381_algorithmic-generation-of-opengl-geometry.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011AlgorithmicGenerationOfOpenGLGeometry275-566.jpg"></media:thumbnail></item><item><title>An (biased) survey of the python web</title><link>http://www.pyvideo.org/video/434/pycon-2011--an--biased--survey-of-the-python-web</link><description>&lt;p&gt;Description&lt;/p&gt;
An (biased) survey of the python web

Presented by Mark Ramm

I may be BDFL of one framework, but that's also why I pay attention to the
whole ecosystem. From the release of Plone 4, TurboGears 2, Django 1.2 and
Pylons 1 ,it's been an interesting year. And things like html5lib, an updated
WSGI spec, and a contender for the next generation WSGI have all made things
interesting. Come explore the wild and dynamic jungle that I call "the python
web toolkit."

Abstract

This talk will not teach people to use python to make websites. It's to teach
people who already use python, that there are lots of different tools out
there, and to help us all get some perspective on the python web toolkit.

In 2005 Pycon had the great PyWebOff, and while this talk won't be about
throwing Twisted into a cage match with Zope3, or setting Flask up in a fight
to the death against web.py, it will one again provide an attempt to survey
the full landscape of the python web world, and to see how far we've come in
the last 5 years.

We've definitely come a long way. Django has brought over many converts to
Python, google released app engine with python as the first supported
language, and there are quite a few sites in the top 100 using python to serve
up dynamic content to hundreds of millions of users.

But it hasn't all been good either, there's more fragmentation than ever.
We've also got more half finished libraries, and broken framework extensions,
and abandoned projects littering up the landscape.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Mark Ramm</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/434/pycon-2011--an--biased--survey-of-the-python-web</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/434_an-biased-survey-of-the-python-web.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011AnBiasedSurveyOfThePythonWeb847.png"></media:thumbnail></item><item><title>An Introduction to Tornado</title><link>http://www.pyvideo.org/video/416/pycon-2011--an-introduction-to-tornado</link><description>&lt;p&gt;Description&lt;/p&gt;
An Introduction to Tornado

Presented by Gavin M. Roy

Tornado is an open source version of the scalable, non-blocking web server and
tools that power FriendFeed. It is not only a web server but it is a light-
weight, use only what you need, web development framework. In this talk we
will review the current state of the Tornado project, review the features
Tornado provides and give examples of how to implement asynchronous web
applications in Tornado.

Abstract

Tornado is an open source version of the scalable, non-blocking web server and
tools that power FriendFeed. It is not only a web server but it is a light-
weight, use only what you need, web development framework. In this talk we
will review the current state of the Tornado project, review the features
Tornado provides and give examples of how to implement asynchronous web
applications in Tornado.

Topics covered will include:

  * Core Tornado concepts 
  * Building an asynchronous web application 
  * Using the Tornado template engine 
  * Database Interaction 
  * Secure cookies and Sessions 
  * Utilizing built-in OAuth Clients for Authentication 
  * Websockets 
  * State of asynchronous drivers available to Tornado 
  * A light introduction to Tornado internals 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Gavin M. Roy</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/416/pycon-2011--an-introduction-to-tornado</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/416_an-introduction-to-tornado.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011AnIntroductionToTornado238.png"></media:thumbnail></item><item><title>An Open success for the cloud: OpenStack</title><link>http://www.pyvideo.org/video/393/pycon-2011--an-open-success-for-the-cloud--openst</link><description>&lt;p&gt;Description&lt;/p&gt;
An Open success for the cloud: OpenStack

Presented by Andy Smith

OpenStack is a collection of open source technologies written entirely in
Python, delivering a massively scalable cloud operating system. OpenStack is
currently developing two interrelated projects: OpenStack Compute and
OpenStack Object Storage. OpenStack Compute is software to provision and
manage large groups of virtual private servers, and OpenStack Object Storage
is software for creating redundant, scalable object storage using clusters of
commodity servers to store terabytes or even petabytes of data.

This talk will go into details about the success of OpenStack with Python,
limitations and how overall, Python was the right technology choice.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Andy Smith</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/393/pycon-2011--an-open-success-for-the-cloud--openst</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/393_an-open-success-for-the-cloud-openstack.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011AnOpenSuccessForTheCloudOpenStack791.png"></media:thumbnail></item><item><title>An outsider's look at co-routines.</title><link>http://www.pyvideo.org/video/396/pycon-2011--an-outsider--39-s-look-at-co-routines</link><description>&lt;p&gt;Description&lt;/p&gt;
An outsider's look at co-routines.

Presented by Peter Portante

Let's take an outsiders look at coroutines, the underlying concept used by
greenlets. First we'll define what they are conceptually, and show some
typical use cases. Then we'll take a look at a sampling of the implementations
out there to see what they are actually doing to implement the concept.
Finally, we'll show their pluses and minuses, and highlight some features of
packages that use them.

Abstract

Talk outline:

  * Define what a coroutine is 
    * Coroutine state not known to operating system 
    * Difference between a thread or process 
    * What state is required for tracking 
  * Show how coroutines are used 
    * gevent example 
    * concurrence example 
  * Review two implementations 
    * Greenlets 
    * Python based co-routines using generators 
  * Advantages/Disadvantages 
  * Differentiating features of packages that use them 
    * Concurrence 
    * Gevent 
    * Eventlets 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Peter Portante</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/396/pycon-2011--an-outsider--39-s-look-at-co-routines</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/396_an-outsider-s-look-at-co-routines.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011AnOutsidersLookAtCoroutines790-929.jpg"></media:thumbnail></item><item><title>API Design anti-patterns</title><link>http://www.pyvideo.org/video/445/pycon-2011--api-design-anti-patterns</link><description>&lt;p&gt;Description&lt;/p&gt;
API Design Anti-Patterns

Presented by Alex Martelli

Designing interfaces so that other code can interact with ours (whether our
code is a library, framework, application, website...) is a very common and
clearly crucial activity, but fraught with dangers -- stuff we all keep doing
wrong time after time. This talks shows some common cases of API design errors
encountered in the wild, with tips on how to avoid them when you design your
next API.

Abstract

Whenever we write code we should always be thinking about how other code
(whether our own, or other people's) will interact with ours (an "API", in
common parlance). Indeed, the most common and terrible mistake in API design
is... not doing any! -- i.e., not providing any designed, architected way for
other code to interact with ours. That's fortunately less common when "our
code" is a library or framework;-), but, alas!, sadly widespread when "our
code" is an application or website -- that's why questions about screen-
scraping the web and simulating keystrokes and mouse gestures need be so
tragically frequent all over the web.

Once past the obvious hurdle of not having any API at all, there's still
plenty of ways we can go badly wrong in the process of designing one -- and
many of those ways fall into recognizable categories, i.e., patterns.
Specifically, since they're frequently observed categories of defective
design, they're anti-patterns -- and that's what this talk is in fact about
(as the smartest among you could tell from the title...).

I'm eminently qualified to present on this subject, since, in a lifetime spent
mostly stumbling into software (after actually qualifying to design hardware
in college, but only doing that for a few years), I've been responsible for
more of my shares of API design fumbles (plus, of course, just like every
other programmer, I've done my share of swearing at the design fumbles of
other API designers). And, as novelist Richard Bach reminds us, "You teach
best what you most need to learn"!-)

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Martelli</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/445/pycon-2011--api-design-anti-patterns</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/445_api-design-anti-patterns.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011APIDesignAntipatterns897.png"></media:thumbnail></item><item><title>API Design: Lessons Learned</title><link>http://www.pyvideo.org/video/366/pycon-2011--api-design--lessons-learned</link><description>&lt;p&gt;Abstract&lt;/p&gt;
API lessons learned from a decade of core Python development.


&lt;p&gt;Description&lt;/p&gt;
Share the lessons learned from a decade of core Python development, what
worked and what didn't. Look at the development process and thinking behind
some of Python's successful APIs and ones that leave something to be desired.
Learn general principles for designing a good API for public consumption.

Hear the story and principles behind the design of Python's "in" operator, the
development of deques, and the evolution of the set API.

Examine the principles and story behind the development of the named tuple
API. Learn about unforeseen use cases and a bug that made it to production.

Discuss the decimal module's API challenge -- adhering to a published
standard. Talk about the Queue module's framework style and how the API was
refactored.

Discuss what we've learned about naming functions and methods. Look at the
i-naming convention in itertools, camelcase oddities, the proposed Italian
name for enumerate, and vaguely named methods like assertItemsEqual.

Learn about Guido's ideas on when to add flags to method signatures. Recap his
thoughts on the problems with the percent formatting operator. Then hear
Raymond's advice on packaging, hierarchies, and nested name spaces.

See how to use documentation to mitigate API problems using examples from
regular expressions, decimal, tokenize, sorting.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Raymond Hettinger</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/366/pycon-2011--api-design--lessons-learned</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/366_api-design-lessons-learned.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011APIDesignLessonsLearned555.png"></media:thumbnail></item><item><title>Backup Is Hard; Let's Go Shopping</title><link>http://www.pyvideo.org/video/424/pycon-2011--backup-is-hard--let--39-s-go-shopping</link><description>&lt;p&gt;Description&lt;/p&gt;
Backup Is Hard; Let's Go Shopping

Presented by Gary Bernhardt

We'll fly through the most clever bits of BitBacker, an online backup app
developed as a startup for three years and eventually abandoned. Highlights: a
hacked-up httplib/asyncore HTTP client; a real-life, HATEOAS-respecting
RESTful API, and an encryption scheme that can quickly diff a file system
against the server while leaking no information – not even file timestamps.

Abstract

This is the story of a solution to a huge problem: fast, secure online backup.
A single client generates a hundred gigabytes, millions of data chunks, and
thousands of file system snapshots. To appreciate the problem's scale,
consider that a Python array holding content hashes for 1,000,000 files
consumes 100 MB of memory. File hashes are only a portion of the required per-
file metadata, and that's only one for snapshot of thousands.

We'll tour the hard parts of this system with no apology for their difficulty.
The httplib/asyncore hybrid monster that served millions of parallel requests,
transparently retrying on failures and timeouts, with only 300 lines of
python. The RESTful API – fully respecting hypertext, with every request
safely repeatable, even POSTs, and not a single hard-coded URL in the client.
The encryption scheme that leaked nothing – not even modification times – but
could quickly diff local file systems against the server. And, that one time
that a client accidentally requested a 4.76 megabyte URL in production.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Gary Bernhardt</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/424/pycon-2011--backup-is-hard--let--39-s-go-shopping</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/424_backup-is-hard-let-s-go-shopping.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011BackupIsHardLetsGoShopping206.png"></media:thumbnail></item><item><title>Best Practices for Impossible Deadlines</title><link>http://www.pyvideo.org/video/391/pycon-2011--best-practices-for-impossible-deadlin</link><description>&lt;p&gt;Description&lt;/p&gt;
Best Practices for Impossible Deadlines

Presented by Christopher Groskopf

At the Chicago Tribune we develop, test, and deploy production web
applications on schedules that range from two hours to two months. This talk
will discuss the tools and techniques that allow us to make our deadlines,
including automated deployments, frameworks, just-in-time testing, and more.
Attention will be paid to [http://github.com/newsapps/beeswithmachineguns](htt
p://github.com/newsapps/beeswithmachineguns) and the problems they solve.

Abstract

On my first day at the Chicago Tribune I was given a CSV of data about
defoliant spraying in Vietnam and told to build this: Agent Orange. What
followed was one of the most stressful and difficult weeks of my life, during
which I learned an incredible amount about web development. I had to stop
thinking about databases and start thinking about serialized JSON structures
stashed on S3; stop thinking about building tools and start thinking about
mashing up tech that was never designed to be married (in this case Simile
Timeline and Google Maps); stop thinking about idealistic development
practices and start thinking about getting a working product out the door. In
short: I had to rewire my brain for news.

This talk will go in-depth on deadline-oriented strategies that I've learned
in a year of building news applications. Some of these revolve around specific
technologies, like fabric for single-keystroke deployments or Varnish for
caching, but most will be matters of practice, like what to test when you have
no time for testing or how to avoid (yes, avoid!) database migrations.

They say Django is "the web framework for perfectionists with deadlines." This
is their Art of War.

Talk outline:

  * An anecdote: Agent Orange 
  * We can't have nice things (or best practices) 
  * Low-hanging fruit: staging environment, git branches, PEP8. 
  * Only build it once: Iterations, interviews and stakeholders 
  * Salvage, share and steal [code] 
  * Keeping track: Be a ticketing warrior 
  * Tools improve faster than you do: iterate your stack 
  * Single-keystroke deployment (fabric) 
  * Migrations are hard: Building read-only apps 
  * Don't serve that: Using S3 for hosting 
  * Caching &gt; optimization (varnish) 
  * Know your load limits (beeswithmachineguns) 
  * Configuration-as-application: application frameworks (maps, tables) 
  * Pair programming &gt; functional testing &gt; unit testing 
  * except UseWordpress, e: print "No, really" 

Sites that will be used as examples:

  * Agent Orange 
  * Burr Oak Memorial 
  * Census 2010: Cook county participation rates map 
  * Area judges and supervision rates of speeders table 
  * RedEye Homicide Tracker 
  * Chicago Tribune Elections Center 
  * 2010 Illinois School Report Cards 
  * TribLocal 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Christopher Groskopf</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/391/pycon-2011--best-practices-for-impossible-deadlin</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/391_best-practices-for-impossible-deadlines.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011BestPracticesForImpossibleDeadlines540-981.jpg"></media:thumbnail></item><item><title>Continuous deployment</title><link>http://www.pyvideo.org/video/407/pycon-2011--continuous-deployment</link><description>&lt;p&gt;Description&lt;/p&gt;
Continuous deployment

Presented by Laurens Van Houtven

This talk is about continuous deployment practices and tools, lessons learned
from implementing it, and putting them into perspective. The goal is to give
other people tips and pointers for applying these ideas themselves.

Abstract

Continuous deployment is the practice of putting the latest revision of
software into production use all the time, as opposed to working towards
larger releases. The important difference is iteration time: whereas large
software packages produce new software in timeframes of years or months,
continuous deployment teams typically put new code into production in
timeframes of hours or less.

The practice is slowly attracting a small but growing group of loyal
followers, just like continuous integration over the past few years and test-
driven development did before that. They can be explained in terms of being
natural extensions of each other. Like TDD and CI, CD gets eyed somewhat
suspiciously (and rightfully so: skeptical analysis is great), but the
undersigned believes there's a legitimate advantage for many applications.

Many years ago, TTD and testing tools in general were mostly ad-hockery. Now,
with many different production-quality testing tools, this has become
unthinkable. Similarly, continuous integration was something other people did
for a long time, but now we have tools such as Buildbot and Hudson. Continuous
deployment is still somewhat in the early stage in terms of ready-to-use
tools, but it's likely that we'll see a similar evolution.

Here's a rough outline of what I plan to cover:

  * a short history of people developed software 
  * from the recent models to CD (sort of a working definition of CD here) 
  * when is it a good idea? pros/cons 
  * requirements &amp; battle plan for applying CD in an existing development environment (and possibly code base) 
  * an overview of existing tools and how they work together 
  * caveat emptors, known pitfalls (deployment and recovery strategies go here, since most implementations figure out they need them after stuff blows up) 
  * questions! (hopefully lots of people who've tried or are thinking about implementing something similar -- like I said, there are a lot of people implementing it but not too many ideas being bounced around) 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Laurens Van Houtven</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/407/pycon-2011--continuous-deployment</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/407_continuous-deployment.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011ContinuousDeployment817.png"></media:thumbnail></item><item><title>CouchDB and Python in practice</title><link>http://www.pyvideo.org/video/429/pycon-2011--couchdb-and-python-in-practice</link><description>&lt;p&gt;Description&lt;/p&gt;
CouchDB and Python in practice

Presented by Luke Gotszling

This talk introduces one 'NoSQL' solution, CouchDB, and how to get it to play
well with Python. Topics covered:

  * Introduction to CouchDB 
  * A python ORM for CouchDB 
  * Parsing CouchDB documents within python 
  * Writing view functions in python 
  * Map/reduce on CouchDB from python 
  * Lessons learned from managing and distributing a live deployment at scale under high load 

Abstract

This is a rough draft

NoSQL

  * CouchDB stores schema free documents 

Why CouchDB?

  * Complicated mapping structures handled 
  * Revision history 
  * Maps nicely to Python objects 
  * HTTP protocol 

Python ORM

  * couchdb-python 
  * Mapping structures 
  * demo 

View functions

  * write in Erlang, Javascript, Python? 
  * demo 

Scaling

  * Distributed map/reduce 
  * BigCouch 
  * Read/write quorum 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Luke Gotszling</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/429/pycon-2011--couchdb-and-python-in-practice</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/429_couchdb-and-python-in-practice.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011CouchDBAndPythonInPractice776.png"></media:thumbnail></item><item><title>Dependency management with Puppet</title><link>http://www.pyvideo.org/video/431/pycon-2011--dependency-management-with-puppet</link><description>&lt;p&gt;Description&lt;/p&gt;
Dependency management with Puppet

Presented by Richard Crowley

Puppet is a configuration management tool that we'll learn to use the easy
way. We'll introduce the Puppet language and the concept of resources like
packages, files, shell commands, and more. We'll use Puppet to build our dev
environment and deploy it to production servers.

Abstract

We've all been there: religiously following the steps in some blog post for
the 47th time trying to setup a shiny new server. We thought we'd improved the
situation when we copied our Bash history into doit.sh and committed it. Then
along came Pip and requirements.txt files.

That's where most of us are today. Pip can only manage Python packages so much
of our servers' behavior is left to Lady Luck. Puppet gives us the power to
efficiently and confidently specify everything our program needs.

We'll start at square one and the concept of resources, the basic unit of
configuration management. We'll learn the Puppet language's resource syntax.
We'll talk about obvious resource types like packages and files plus less
obvious types like shell commands, users, groups, and daemons. We'll compose
resources into larger ones, declare dependencies between resources, and
accommodate differences between OS X and Linux.

These Puppet manifests can satisfy our program's dependencies on demand,
making them ideal parts of the deploy process. We'll walk through how Puppet
is used to build production environments both through tools such as Fabric and
Puppet's traditional client-server mode.

Dependency hell doesn't have to be your reality. Consistent, reliable
environments can be had with Puppet.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Richard Crowley</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/431/pycon-2011--dependency-management-with-puppet</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/431_dependency-management-with-puppet.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011DependencyManagementWithPuppet645.png"></media:thumbnail></item><item><title>Deploying Applications with zc.buildout</title><link>http://www.pyvideo.org/video/426/pycon-2011--deploying-applications-with-zc-buildo</link><description>&lt;p&gt;Description&lt;/p&gt;
Deploying Applications with zc.buildout

Presented by JIm Fulton

This talk described using zc.buildout for application deployment to production
environments. It presents building self-contained source releases, and using
these to create RPM distributions. It shows how to use buildout to configure
services, including web servers, cron jobs, monitoring and so on. Finally, it
presents ongoing efforts to deploy applications that span many machines.

Abstract

We build and deploy large Python applications for our customers. These
applications are built from many component parts including Python packages and
non-python applications and tools. Assembling these pieces can be a tedious
and error-prone process. The zc.buildout (Buildout) package was developed to
automate this process.

As our use of buildout has matured, we've integrated it with system packaging
tools and developed techniques for managing software deployemnt and service
configuration. I'll provide a detailed description of the techniques and tools
used.

Outline:

  * Buildout 
    * Motivation 
    * History 
    * Configuration files 
    * Recipes 
  * Deployment pholisophy: keeping software and service configuration separate 
  * System Packaging 
    * Making self-contained source releases (tar balls) 
    * Creating system packages from source releases with RPM 
  * Service configuration -- system build outs 
    * Scope: Python processes, cron, log rotation, run scripts, monitoring, etc. 
    * Place files in "standard" locations. 
    * Run by root 
    * examples 
  * Meta recipes 
    * Goal: provide only essential information. 
    * Recipes provide basic level of abstraction. 
    * Buildout provides basic tools to build on these abstractions, but these tools only scale so far. 
    * Buildout configuration language is *not* a programming language. 
    * Meta-recipes provide a much more powerful way to build high-level abstractions over basic recipes. 
  * Next step: Make me a ... 
    * Model based definition of complete systems spanning multiple hosts with interlocking services 
    * Automatic management of resources 
    * Implemented with ssh, system packaging tools (e.g. yum) and buildout-based tools. 
    * Four levels of abstraction 
    * Current status 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">JIm Fulton</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/426/pycon-2011--deploying-applications-with-zc-buildo</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/426_deploying-applications-with-zc-buildout.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011DeployingApplicationsWithZcbuildout710.png"></media:thumbnail></item><item><title>Disqus: Serving 400 million people with Python</title><link>http://www.pyvideo.org/video/418/pycon-2011--disqus--serving-400-million-people-wi</link><description>&lt;p&gt;Description&lt;/p&gt;
Disqus: Serving 400 million people with Python

Presented by David Cramer and Jason Yan

Disqus, one of the largest Python applications on the web, will explain how
they deal with scaling complexities in a growing startup. Founded in 2007,
Disqus maintains a small engineering team reaching over 400 million users a
month. Being powered by Python has allowed quick iteration of the application,
without sacrificing code quality and performance. The talk will cover key
parts of the architecture and development process at Disqus, including
hardware, databases, and common bottlenecks.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Cramer,Jason Yan</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/418/pycon-2011--disqus--serving-400-million-people-wi</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/418_disqus-serving-400-million-people-with-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011DisqusServing400MillionPeopleWithPython212.png"></media:thumbnail></item><item><title>Distributed Tasks with Celery</title><link>http://www.pyvideo.org/video/452/pycon-2011--distributed-tasks-with-celery</link><description>&lt;p&gt;Description&lt;/p&gt;
Distributed Tasks with Celery

Presented by Ryan Petrello

Celery is an open source task queueing system based on distributed message
passing, especially using the AMQP protocol. This talk will focus on the need
for task distribution, the tools celery provides to meet those needs, and an
in-depth discussion of how we've used celery at ShootQ to improve the
efficiency and reliability of our background processes.

Abstract

The talk (including time for questions) will last approximately 30 minutes and
will focus on the following topics:

  * The need for distributed tasks in real world systems, especially in a web application environment. This portion of the talk will describe examples where the traditional request-response model of the web can be improved with background processing. 
  * A brief overview of traditional distributed message passing models and the AMPQ protocol. 
  * An overview of Celery and the variety of tools it provides for task distribution, scheduling, and execution. This portion of the talk will also review production-oriented components of Celery, such as monitoring, error detection/reporting, and error recovery. 
  * Real world discussion of several problems we solved at ShootQ using Celery including before-and-after looks at our implementations. 
  * Common pitfalls and gotchas we encountered while working with Celery. 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Ryan Petrello</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/452/pycon-2011--distributed-tasks-with-celery</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/452_distributed-tasks-with-celery.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011DistributedTasksWithCelery711.png"></media:thumbnail></item><item><title>Diversity in Tech: Improving our Toolset</title><link>http://www.pyvideo.org/video/374/pycon-2011--diversity-in-tech--improving-our-tool</link><description>&lt;p&gt;Description&lt;/p&gt;
Diversity in Tech: Improving our Toolset

Presented by Jennifer Leech

As communities allow more diversity, they draw from a larger talent pool,
challenge each other more, and hit a higher bar in terms of ingenuity and
work-product. However questions surrounding diversity often seem under-
examined. What are the effects of diversity in the community, or lack thereof?
I intend to approach this topic from an accessible and entertaining, yet
analytical perspective.

Abstract

Last year there was a photo of Kate Moss shown during a PyCon presentation
which raised debate as to its appropriateness. This debate brought up some
interesting questions - but what I found most interesting was that while it
elicited strong opinions, the issue seemed to be somewhat unexamined. This
event sparked a desire for deeper analysis on this topic in a more focussed
setting.

In this talk, I intend to address some of the core principles underlying this
debate. Discussion will include the following questions: Where does
responsibility lie in understanding these issues? What are the effects of
failing to do so? What are the effects of diversity in the community, or lack
thereof? What do we lose by being more homogenous or more diverse? Gain?

As communities allow more diversity, they draw from a larger talent pool,
challenge each other more, and hit a higher bar in terms of ingenuity and
work-product. However, diversity requires awareness and tolerance on both the
part of the dominant culture and on the part of the new arrivals to smooth the
inevitable rough edges.

I intend to approach this topic from an accessible, inclusive and
entertaining, yet analytical perspective. The broader intent is to raise the
level of understanding and community discourse on this topic. It is odd that
diversity can so dramatically affect our lives and communities and yet be
unexamined, particularly in a community so highly intelligent and educated as
that which populates the tech industry.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jennifer Leech</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/374/pycon-2011--diversity-in-tech--improving-our-tool</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/374_diversity-in-tech-improving-our-toolset.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011DiversityInTechImprovingOurToolset347.png"></media:thumbnail></item><item><title>Django Packages: A Case Study</title><link>http://www.pyvideo.org/video/448/pycon-2011--django-packages--a-case-study</link><description>&lt;p&gt;Description&lt;/p&gt;
Django Packages: A Case Study

Daniel Greenfeld

Django Packages is the place to review Django apps, frameworks, and projects.
This talk is for everyone, including non-Django users, and covers everything
from architecture, API development, to interacting with PyPI, Github,
Bitbucket, etc. It will include tools, lessons learned, and projects that fork
the code to save the world and will finish with an overview of the forthcoming
pypackages.com.

Abstract

Since launch Django Packages has become the place to find and compare apps,
frameworks and projects produced by the Django Community. Through the use of
public APIs, Django Packages constantly fetches hard data from PyPI, Github,
and Bitbucket, aproviding a powerful mash-up of real-world data on the volume
of usage of a particular package. At a glance you can see which package is the
most downloaded, which is the most used, and which has seen ongoing
development.

The project is open sourced on Github, with all non-user data accessible
available via the API. Django Packages was conceived and and launched in the
2010 Django Dash. Since launch it has seen features added incrementally and
was a frequently mentioned project at the 2010 DjangoCon and was #1 on Hacker
News on Sunday, December 5, 2010. It's purpose is to provide a place for
Django Developers to submit, research, and review apps, projects, and
frameworks.

The talk will cover:

  * Launching the project 
    * The pre-Django Packages state of finding Django apps 
    * Grids, not tags 
    * Only hard metrics allowed, no opinions or rating systems! 
    * Slurping content from PyPI, Github, Bitbucket, Launchpad, SourceForge, and Google Project Hosting 
    * Lessons Learned AKA The Zen of Python and PEP-8 
    * Deployment and backups 
  * The Month after launch 
    * New feature considerations 
    * Handing over the keys to reduce bus factor 
    * Excitement when seeing it being used as a reference 
  * DjangoCon 
    * Sprint tactics for your pet project 
    * Development of an API 
    * Github, Google Project Hosting, and PyPI 
  * Going forward 
    * Planned new features for Django Packages 
    * Forking Django Packages to save the world 
    * pypackages.com - a forthcoming place to review Python applications, frameworks, and packages 

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/448/pycon-2011--django-packages--a-case-study</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/448_django-packages-a-case-study.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011DjangoPackagesACaseStudy119.png"></media:thumbnail></item><item><title>Django: Pitfalls I Encountered and How to Avoid Them</title><link>http://www.pyvideo.org/video/390/pycon-2011--django--pitfalls-i-encountered-and-ho</link><description>&lt;p&gt;Description&lt;/p&gt;
Django: Pitfalls I Encountered and How to Avoid Them

Presented by Luke Sneeringer

Are you starting a moderate to large sized Django project? Do you need to plan
ahead and build an application that will react to unanticipated needs? This
talk covers some techniques and pitfalls I encountered in writing my first
reasonably large Django site, and what I did differently the second time I
started a project.

Abstract

When working on a company product, especially one where developers don't
always have full control over the scope and needs of the application, it's
important to plan ahead for unanticipated needs.

This talk will cover simple tricks and methods that are a small amount of work
up front, but can save you lots of time later.

PyCon Talk Outline

  1. Introduction (5m) 
    * Me! 
  2. Making Mistakes 
    * It happens. "Code quality can be measured by the number of WTFs per minute in the code review." 
    * When dealing with a big, expansive framework like Django, sometimes you just don't know that something is there. Good docs don't completely solve this...there's always going to be the thing you don't find. Similarly, sometimes you don't realize how to leverage something that you do know about until much later.  
  
My regrets with my current project aren't sweeping architectural issues. I did
most of the big stuff right. My regrets are mostly small things that, because
it was my first big project, there was this piece or that piece that I didn't
see or didn't fully appreciate, and so now I have little blocks of code that
are tougher to maintain than they need to be. End of the world? No. Worth
thinking through for next time? Yes.

  3. Some trivial things (10m) 
    * Preface: Yeah, some of these are dumb. 
    * Beginning at the beginning: Project Setup 
      * I had sys.path pointing to the directory above the project root, like the tutorial does. I wish I hadn't done that. 
      * Need to run two instances on the same box that don't share the actual codebase (e.g. a staging server)? You still can, but it's more awkward. Better to set sys.path at your project root. 
    * Dude, where's my Media class? 
      * How did I do it? First I had a magic template variable. Then I copied Form.Media 
      * Then, on a later project, I realized a block works just fine. 
    * My boss wants ____ available on every page! 
      * How did I do it? I had a method we called everywhere that took arbitrary keyword arguments... 
      * Oh, there's TEMPLATE_CONTEXT_PROCESSORS... 
        * ...if you manually use RequestContext every time! So, just do that. Always. Even if you don't need it. 
        * I want .select_related('something') every time! 
        * ...so I typed it! A lot. 
        * Oh, that can be done by overriding def queryset on the manager class? That's easier to maintain... 
          * ...but make sure you set the flag to use it on related fields! 
    * We need sample data for so-and-so, such-and-such... 
      * Disclaimer: This one actually isn't mine; my boss did it. But, it's amusing, and worth mentioning. 
      * We needed sample data so my boss could preview themes...so he set up a second database, put in fake data, and hard-coded it in the app-wide (not server-specific) settings.py. 
        * Copied the entire DB structure...at the time. But it changes. 
        * Oh, and the unit testing framework didn't appreciate it, either. 
      * Fixtures are the right way (and sooner or later I'll get this fixed...it's still there). 
        * (space reserved for my stumbling upon something else silly, and hopefully humorous, that I did wrong) 
          1. How to avoid missing trivial things? 
    * Read the documentation. Over and over. 
    * Become familiar with the Django code. 
  4. A non-trivial thing: Forms (10m) 
    * Django forms can do anything...given sufficient shenanigans. Always do it the Django forms way; your life will be easier. 
    * Forms and ModelForms are static, and I needed dynamic choices on a form... 
      * ...so I just ditched newforms 
      * But wait, this is Python. A trivial function that calls the metaclass can solve this problem! 
        * This looks complicated, but it's not. Walk through how to do it. 
        * It's quite maintainable, and you get all the other bells and whistles. 
  5. Questions? (5m)

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Luke Sneeringer</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/390/pycon-2011--django--pitfalls-i-encountered-and-ho</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/390_django-pitfalls-i-encountered-and-how-to-avoid-them.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011DjangoPitfallsIEncounteredAndHowToAvoidThem207-415.jpg"></media:thumbnail></item><item><title>Documentation Driven Development</title><link>http://www.pyvideo.org/video/441/pycon-2011--documentation-driven-development</link><description>&lt;p&gt;Description&lt;/p&gt;
Documentation Driven Development

Presented by Corey Oordt

Developers usually leave documentation as a final step; one that they will get
to as soon as they are forced with threats of bodily harm. Writing the
documentation before writing the code, can lead to better code, better
implementation and, of course, actual documentation.

Abstract

"Documentation Driven Design" was coined by our team after noticing how
documenting code dramatically changed how we approached problems. By writing
the documentation first, you saw the problem from a different perspective: the
end user or programmer. This talk will focus on a few items:

Usable, not just functional. Many times developers write code that solves the
problem, but is a real pain in the neck to use. Writing the documentation
first demonstrates how easy or difficult it is to implement the solution right
away.

A guide to what to write. Many developers leave documentation undone because
they don't know how to approach it. Having some idea of what needs writing can
make the task seem less daunting.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Corey Oordt</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/441/pycon-2011--documentation-driven-development</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/441_documentation-driven-development.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011DocumentationDrivenDevelopment665.png"></media:thumbnail></item><item><title>"Dude, Where's My RAM?" - A deep dive into how Python uses memory</title><link>http://www.pyvideo.org/video/451/pycon-2011---quot-dude--where--39-s-my-ram--quot-</link><description>&lt;p&gt;Description&lt;/p&gt;
"Dude, Where's My RAM?" - A deep dive into how Python uses memory

Presented by Dave Malcolm

This talk will give a deep dive into how CPython uses memory. I'll be
demonstrating a new tool I've written that analyses CPython's memory usage,
and offer hints and tips on how you can reduce the memory footprint of your
Python programs.

Abstract

Is your Python program using too much memory? This talk will give a deep dive
into how CPython uses memory - starting from objects in your Python code, down
through the various implementations layers, eventually reaching actual
hardware.

In particular, I'll be demonstrating a new tool I've written that can track
CPython's memory usage down to the level of individual bytes, and offer hints
and tips on how you can reduce the memory footprint of your Python programs.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Dave Malcolm</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/451/pycon-2011---quot-dude--where--39-s-my-ram--quot-</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/451_dude-where-s-my-ram-a-deep-dive-into-how-python-uses-memory.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011DudeWheresMyRAMADeepDiveIntoHowPythonUses951.png"></media:thumbnail></item><item><title>Everything You Wanted To Know About Pickling, But Were Afraid To Ask!</title><link>http://www.pyvideo.org/video/384/pycon-2011--everything-you-wanted-to-know-about-p</link><description>&lt;p&gt;Description&lt;/p&gt;
Everything You Wanted To Know About Pickling, But Were Afraid To Ask!

Presented by Richard T. Saunders

Serializing data structures (in Python-speak "pickling") to save to
disk/socket is an important tool for the programmer: We will discuss how the
pickling protocols (0,1,2, and 3) work as well as real-world issues (gotchas,
backwards-compatibility, etc). We will concentrate on the basics of this
stack-based protocol: what it looks like, how to encode/decode, speeds of
different implementations.

Abstract

The Pickling Protocols are a fundamental tool for saving state.

We will discuss the differences between text serialization and Python pickling
(as well as marshalling, and simple bit-blitting).

We will spend a little time discussing history: why there is a cPickle and
pickle module in 2.x and only pickle in 3.x., and why there are 4 different
protocols: 0,1,2 and 3.

We will then dive right in and look at how the stack-based protocol works. We
will concentrate on the basics (the stack-based machine), as all the protocols
adhere to this basic model, but tend to discuss the more recent protocols and
their differences. We will also discuss how the memoization scheme works.

We will show some simple examples and then build to more complex examples.

We will also discuss the relative speeds: the different protocols (text,
0,1,2,3) and the different implementations (Python, Boost, PicklingTools,
IronPython?, PyPy? Unladen Swallow?).

We will end with some real-world advice and some gotchas to watch out for
(32-bit vs. 64-bit, different versions of Python serialize differently, etc.).

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Richard T. Saunders</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/384/pycon-2011--everything-you-wanted-to-know-about-p</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/384_everything-you-wanted-to-know-about-pickling-but-were-afraid-to-ask.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011EverythingYouWantedToKnowAboutPicklingButWere385.png"></media:thumbnail></item><item><title>Exhibition of Atrocity</title><link>http://www.pyvideo.org/video/401/pycon-2011--exhibition-of-atrocity</link><description>&lt;p&gt;Description&lt;/p&gt;
Exhibition of Atrocity

Presented by Mike Pirnat

Believe it or not, but you can write pretty horrendously awful code even in a
language as elegant as Python. Over the years, I've committed my share of
sins; now it's time to come clean. Step right up for a tour of twisted, evil,
and downright wrong code, and learn some strategies to avoid writing
criminally bad code--if you dare!

Abstract

What does it look like when good intentions go horribly wrong? This talk will
take a tour through pathological code from my past (as well as some
contributions from friends, coworkers, and the community), featuring such
terrors as:

  * Lies, Damn Lies, and Hungarian Notation 
  * Crimes Against PEP-8 
  * The Diaper Pattern 
  * The Beast With a Thousand Elifs 
  * The Mile-Long Club 
  * God Objects and God Methods 
  * The Malignant Menace of Mutable Keyword Arguments 
  * The Seductive Lure of Global State 
  * Slower Applications Through DTO Bondage 
  * A Twisty Maze of Single-Character Variables, All Alike 
  * Lambdas, Lambdas Everywhere 
  * The List Comprehension That Ate Cincinnati 
  * Adventures in Wheel Reinvention 
  * New and Creative Ways to Break the Build 

...as well as others as time permits.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Mike Pirnat</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/401/pycon-2011--exhibition-of-atrocity</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/401_exhibition-of-atrocity.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011ExhibitionOfAtrocity736.png"></media:thumbnail></item><item><title>Extreme Network Programming with Python and Linux</title><link>http://www.pyvideo.org/video/449/pycon-2011--extreme-network-programming-with-pyth</link><description>&lt;p&gt;Description&lt;/p&gt;
Extreme Network Programming with Python and Linux

Presented by Rob Ludwick

Traditionally, C is the preferred language for low level network programming
and works well for those who have the time and patience to work with it. As it
turns out, Python is very capable for prototyping low level network code,
collecting data, and testing ideas quickly without getting lost in the land of
C.

Abstract

While not as robust as C, Python provides a simple and elegant solution for
many cases to either prove a theory or gather data before developing a more
robust solution. Obscure topics such as raw sockets, multicast, network
bridging, rolling your own vpn, and disruption tolerant networking will be
covered. Use of Python can enable building a custom protocols, debugging a
network, fixing broken nets, custom logging and processing, and simulation of
networks. The author will talk about his experiences using Python on Linux for
extreme network programming and possibilities for future efforts.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rob Ludwick</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/449/pycon-2011--extreme-network-programming-with-pyth</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/449_extreme-network-programming-with-python-and-linux.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011ExtremeNetworkProgrammingWithPythonAndLinux128.png"></media:thumbnail></item><item><title>Firefox Sync</title><link>http://www.pyvideo.org/video/376/pycon-2011--firefox-sync</link><description>&lt;p&gt;Description&lt;/p&gt;
Firefox Sync

Presented by Tarek Ziadé

Firefox Sync let you access your history, passwords, bookmarks and even open
tabs across all your devices, while remaining unreadable on the server through
encryption. After a brief introduction on the Sync protocol, this talk will
focus on the server, which is written in Python.

Abstract

The talk will briefly explain how Syncing works then will focus on the Server
architecture and code. You will discover through this talk how the server was
built and what technologies it uses.

  1. Firefox Sync in numbers 
  2. How synchronisation happens - the big picture 
    1. Desktop
    2. iPhone (Firefox Home)
  3. How encryption works
  4. Overview of the APIs 
    1. Sync 1.1
    2. User 1.0
  5. Server architecture 
    1. User &amp; Data storage
    2. Web Services
    3. Libraries used
  6. Scaling and benchmarking
    1. Grinder
    2. Funkload
  7. Run your own server !
  8. What's Next

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tarek Ziadé</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/376/pycon-2011--firefox-sync</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/376_firefox-sync.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011FirefoxSync705-934.jpg"></media:thumbnail></item><item><title>Friday Afternoon Lightning Talks</title><link>http://www.pyvideo.org/video/360/pycon-2011--friday-afternoon-lightning-talks</link><description>&lt;p&gt;Abstract&lt;/p&gt;
Friday afternoon lightning talks


&lt;p&gt;Description&lt;/p&gt;
Friday afternoon lightning talks

  * 00:00 Paul Smith - Raising money for Japan 
  * 02:24 Jeff Daily - The Global Arrays Parallel Programming Toolkit 
  * 08:30 Matt Harrison - My insecurity problem 
  * 13:10 Pete Fein - Hacking for Freedom 
  * 18:40 Robert Brewer - logging.statistics 
  * 27:30 Nathan Nichols - Lessons Learned Writing DSLs for Automated Content Generation 
  * 33:15 Giles Thomas - Why Resolver switched from IronPython to CPython 
japan, qtile, pyparsing, logging.statistics, resolver, cpython, ironpython

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/360/pycon-2011--friday-afternoon-lightning-talks</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/360_friday-afternoon-lightning-talks.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011FridayAfternoonLightningTalks981.png"></media:thumbnail></item><item><title>Fun with Python's Newer Tools</title><link>http://www.pyvideo.org/video/367/pycon-2011--fun-with-python--39-s-newer-tools</link><description>&lt;p&gt;Abstract&lt;/p&gt;
Spend ten minutes each learning to work with Counters, named tuples, new
string formatting, and the LRU cache. Learn the basic API, see how it works
under the hood, enjoy a simple example, and then have fun pushing it to the
limit in interesting ways.


&lt;p&gt;Description&lt;/p&gt;
Look at how a Counter is implemented. See a simple word count example. Use a
counter for unittests. Implement a sparse matrix.

Show how named tuples are created, combined, subclassed, and extended. See how
to implement an Enum class and how to create default values.

Learn the basics of the new string formatting syntax. See how to use it for
templating.

Show everyday uses for an LRU cache, look at the underlying implementation,
and see how to use it to trivially solve a dynamic programming problem.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Raymond Hettinger</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/367/pycon-2011--fun-with-python--39-s-newer-tools</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/367_fun-with-python-s-newer-tools.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011FunWithPythonsNewerTools386-808.jpg"></media:thumbnail></item><item><title>Genetic Programming in Python</title><link>http://www.pyvideo.org/video/428/pycon-2011--genetic-programming-in-python</link><description>&lt;p&gt;Description&lt;/p&gt;
Genetic Programming in Python

Presented by Eric Floehr

Did you know you can create and evolve programs that find solutions to
problems? This talk walks through how to use Genetic Algorithms and Genetic
Programming as tools to discover solutions to hard problems, when to use
GA/GP, setting up the GA/GP environment, and interpreting the results. Using
[pyevolve](http://pyevolve.sourceforge.net/), we'll walk through a real-world
implementation creating a GP that predicts the weather.

Abstract

Genetic Algorithms (GA) and Genetic Programming (GP) are methods used to
search for and optimize solutions in large solution spaces. GA/GP use concepts
borrowed from natural evolution, such as mutation, cross-over, selection,
population, and fitness to generate solutions to problems. If done well, these
solutions will become better as the GA/GP runs.

GA/GP has been used in problem domains as diverse as scheduling, database
index optimization, circuit board layout, mirror and lens design, game
strategies, and robotic walking and swimming. They can also be a lot of fun,
and have been used to evolve aesthetically pleasing artwork, melodies, and
approximating pictures or paintings using polygons.

GA/GP is fun to play with because often-times an unexpected solution will be
created that will give new insight or knowledge. It might also present a novel
solution to a problem, one that a human may never generate. Solutions may also
be inscrutable, and determining why a solution works is interesting in itself.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Eric Floehr</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/428/pycon-2011--genetic-programming-in-python</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/428_genetic-programming-in-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011GeneticProgrammingInPython350.png"></media:thumbnail></item><item><title>Get new contributors (and diversity) through outreach</title><link>http://www.pyvideo.org/video/415/pycon-2011--get-new-contributors--and-diversity--</link><description>&lt;p&gt;Description&lt;/p&gt;
Get new contributors (and diversity) through outreach

Presented by Asheesh Laroia

Groups like the Fedora Design Team, Dreamwidth, SF Ruby, and OpenHatch have
discovered the power of outreach to bring in new contributors. In the past
year, SF Ruby grew in numbers as well as in diversity, moving from 3% women to
18% women. Because most projects need ongoing help, this talk discusses
effective strategies for bringing in contributors who stick around for the
long haul.

Abstract

This talk is targeted at anyone involved in an open source project who wants
to find more contributors.

Programs like Google Summer of Code often provide excited students who
disappear after a summer's work. Meanwhile, request for help emails on
development lists are typically met with silence. Hackathons create a flurry
of commits, but then we never hear from the participants again. Expanding your
team is possible, and it requires care in terms of outreach, expectation
management, and mentorship.

We will discuss three major forms of outreach:

  * One-on-one check-ins with participants, 
  * Periodic drives to bring in new contributors, and 
  * In-person teaching events. 
Each one has "do"s and "don't"s associated with it. This talk digests the
experience of effective outreach into practical strategies that you can re-use
within your project.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Asheesh Laroia</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/415/pycon-2011--get-new-contributors--and-diversity--</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/415_get-new-contributors-and-diversity-through-outreach.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011GetNewContributorsAndDiversityThroughOutreach225.png"></media:thumbnail></item><item><title>Getting the job: the do's and don'ts of landing a Python job</title><link>http://www.pyvideo.org/video/408/pycon-2011--getting-the-job--the-do--39-s-and-don</link><description>&lt;p&gt;Description&lt;/p&gt;
Getting the job: the do's and don'ts of landing a Python job

Presented by Brian Moloney

Every Python programmer is brilliant in his or her own way. That brilliance
shines in code and peer-to-peer conversation. But how do you display your
skills to a non-programmer? How do you impress management and human resources?
What do you need to do (and not do) to successfully navigate the hiring
process and land the job?

Abstract

Imaginary Landscape has been interviewing, hiring and not hiring Python talent
since 1999. Throughout these many years, there have been good candidates, bad
candidates and downright ugly candidates. This talk will use actual
correspondence and examples to demonstrate what can separate you from the
crowd and what can separate you from consideration. Imaginary Landscape non-
technical Managing Partner Brian Moloney will lead the session by describing
how he evaluates potential hires and what goes through his mind while speaking
with potential Python candidates. Attendees will take away a specific set of
guidelines for mastering the non-technical aspects of the recruiting process.

[VIDEO HAS ISSUES: There are problems with the audio for the first 5 minutes.]

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Brian Moloney</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/408/pycon-2011--getting-the-job--the-do--39-s-and-don</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/408_getting-the-job-the-do-s-and-don-ts-of-landing-a-python-job.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011GettingTheJobTheDosAndDontsOfLandingAPython220.png"></media:thumbnail></item><item><title>Going Full Python - Threadless</title><link>http://www.pyvideo.org/video/385/pycon-2011--going-full-python---threadless</link><description>&lt;p&gt;Description&lt;/p&gt;
  

Going Full Python -- Threadless

Presented by Chris McAvoy

Threadless is a 10 year old community based design company with an
overpowering love of witty t-shirts and a mission to 'inspire awesomeness.'
After 10 years of working primarily with PHP, Threadless has decided to use
Python as our base development language. The decision was 10% technical and
90% touchy feely. We know what a powerful community can do to a product, and
see the same sort of drive and passion in the Python community that we see in
our own design community. Python is the peanut butter to our jelly. We're
excited to share our jelly with you. Chris McAvoy, VP of Technology at
Threadless (and the founder of the Chicago Python Users Group), will share a
bit about the companies history, the role of technology in supporting the
community at the core of the business, and why Python and Threadless are going
to be totally BFF's.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris McAvoy</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/385/pycon-2011--going-full-python---threadless</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/385_going-full-python-threadless.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011GoingFullPythonThreadless741.png"></media:thumbnail></item><item><title>Greasing the Wheels of Exploration with Python</title><link>http://www.pyvideo.org/video/369/pycon-2011--greasing-the-wheels-of-exploration-wi</link><description>&lt;p&gt;Abstract&lt;/p&gt;
The control of the Mars Exploration Rovers (MER) requires a complex set of
coordinated activites by a team. Early in the MER mission the author automated
in Python much of the task of one of the operation positions, the Payload
Uplink Lead, for 7 of the 9 cameras on each rover. This talk describes the MER
rovers, the operation tasks and that implemented system.


&lt;p&gt;Description&lt;/p&gt;
The Mars Exploration Rovers (MER), Spirit and Opportunity, have been roaming
the surface of Mars since January of 2004 leading to many discoveries about
the nature and history of our sister planet. Each activity requires a complex
set of coordinated activites by a team. Early in the MER mission the author
automated much of the task of one of the positions, the Payload Uplink Lead,
for 7 of the 9 cameras on each rover. The system, called AutoPUL, is written
in Python and that has proven to be the excellent choice for the development
and maintenance. In the talk I'll describe the Mars Rover mission and the
operational activities and how AutoPUL and Python fullfilled those needs.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael Sims</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/369/pycon-2011--greasing-the-wheels-of-exploration-wi</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/369_greasing-the-wheels-of-exploration-with-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011GreasingTheWheelsOfExplorationWithPython860-969.jpg"></media:thumbnail></item><item><title>Handling ridiculous amounts of data with probabilistic data structures</title><link>http://www.pyvideo.org/video/402/pycon-2011--handling-ridiculous-amounts-of-data-w</link><description>&lt;p&gt;Description&lt;/p&gt;
Handling ridiculous amounts of data with probabilistic data structures

Presented by C. Titus Brown

Part of my job as a scientist involves playing with rather large amounts of
data (200 gb+). In doing so we stumbled across some neat CS techniques that
scale well, and are easy to understand and trivial to implement. These
techniques allow us to make some or many types of data analysis map-reducable.
I'll talk about interesting implementation details, fun science, and neat
computer science.

Abstract

If an extreme talk, I will talk about interesting details/issues in:

  1. Python as the backbone for a non-SciPy scientific software package: using Python as a frontend to C++ code, esp for parallelization and testing purposes. 
  2. Implementing probabilistic data structures with one-sided error as pre-filters for data retrieval and analysis, in ways that are generally useful. 
  3. Efficiently breaking down certain types of sparse graph problems using these probabilistic data structures, so that large graphs can be analyzed straightforwardly. This will be applied to plagiarism detection and/or duplicate code detection. 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">C. Titus Brown</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/402/pycon-2011--handling-ridiculous-amounts-of-data-w</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/402_handling-ridiculous-amounts-of-data-with-probabilistic-data-structures.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011HandlingRidiculousAmountsOfDataWithProbabilisti974.png"></media:thumbnail></item><item><title>Hidden Treasures in the Standard Library</title><link>http://www.pyvideo.org/video/370/pycon-2011--hidden-treasures-in-the-standard-libr</link><description>&lt;p&gt;Description&lt;/p&gt;
Hidden Treasures in the Standard Library

Presented by Doug Hellmann

This presentation covers features of the standard library not widely known or
used. Each feature is presented with a short demonstration program and
explanation.

Abstract

The standard library contains many hidden gems that are not widely used,
either because they are not publicized enough or because they are deep in a
module that programmers haven't had cause to study or use. This presentation
covers 8-10 selected topics of this nature in about 25 minutes (leaving time
for a couple of questions). Demonstration code is included for every item.

Possible tips include, in no particular order:

  * Using hmac to verify pickled data before unpacking it. 
  * Using uuid4 to generate session tokens. 
  * Regular expression look-ahead/behind matches. 
  * pdb startup files 
  * Reading files with mmap 
  * Using csv dialects 
  * The robotparser module 
  * The rlcompleter module 
  * Using locale to format numbers and currency 
  * The cgitb module 
  * pkgutil.getdata 
  * contextlib.contextmanager 
  * The cmd module 
  * The fileinput module 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Doug Hellmann</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/370/pycon-2011--hidden-treasures-in-the-standard-libr</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/370_hidden-treasures-in-the-standard-library.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011HiddenTreasuresInTheStandardLibrary179-925.jpg"></media:thumbnail></item><item><title>Hookbox: All Python web-frameworks, now real-time. Batteries Included.</title><link>http://www.pyvideo.org/video/371/pycon-2011--hookbox--all-python-web-frameworks--n</link><description>&lt;p&gt;Description&lt;/p&gt;
Hookbox: All Python web-frameworks, now real-time. Batteries Included.

Presented by Michael Carter

Learn how to supercharge your python web applications (Django, Pylons, TG,
GAE, Werkzeug, WSGI, etc) with real-time features! Presenceful and moderated
chat? About 10 minutes, seriously. A real-time graph to monitor the CPU? Less
than five. If you pay attention for at least half of this talk, you'll leave
confident and ready to take advantage of WebSocket, Comet, and the world,
thanks to Hookbox.

Abstract

Hookbox ([http://hookbox.org](http://hookbox.org/)) is a Python and Eventlet-
based Comet-server/message-queue which tightly integrates with existing web
application infrastructure via web hooks and a REST interface; Hookbox’s
purpose is to ease the development of real-time web applications, with an
emphasis on tight integration with existing web technology. Put simply,
Hookbox is a web-enabled message queue.

Browers may directly connect to Hookbox, subscribe to named channels, and
publish and receive messages on those channels in real-time. An external
application (typically the web application itself) may also publish messages
to channels by means of the Hookbox REST interface. All authentication and
authorization is performed by an external web application via designated
“webhook” callbacks.

In this talk we cover the broad principles of Hookbox, then examine a few
short examples in depth, including presenceful and moderated chat, real-time
graphing, and, of course, a game. The code examples are very purposefully
brief; the important parts of the talk deal with the interaction model between
browser, web framework, and Hookbox -- everything else follows naturally and
easily into place.

The audience need not be familiar with a particular web framework over
another, but they must be proficient with at least one.

Though this talk is aimed at a novice level, we'll also spend some time
talking about the more advanced features that Hookbox provides.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael Carter</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/371/pycon-2011--hookbox--all-python-web-frameworks--n</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/371_hookbox-all-python-web-frameworks-now-real-time-batteries-included.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011HookboxAllPythonWebframeworksNowRealtimeBatteri858.png"></media:thumbnail></item><item><title>How to kill a patent with Python</title><link>http://www.pyvideo.org/video/425/pycon-2011--how-to-kill-a-patent-with-python</link><description>&lt;p&gt;Description&lt;/p&gt;
How to kill a patent with Python

Presented by Van Lindberg

Finding the right piece of "prior art" - technical documentation that
described a patented piece of technology before the patent was filed - is like
finding a needle in a very big haystack. This session will talk about how I am
making that process faster and more accurate through the use of natural
language processing, graph theory, machine learning, and lots of Python.

Abstract

From my work consulting on a number of patent cases, I am frequently asked to
find "prior art" - patents and publications that describe a technology before
a certain date. The problem is that the indexing mechanisms for patents and
publications are not as good as they could be, making good prior art searching
more of an art than a science. When I decided to do better, I reached for
Python.

  * Part I (5 mins): The USPTO as a data source.* The full-text of each patent is available from the USPTO (and now from Google.) What does this data look like? How can it be harvested and normalized to create data structures that we can work with? 
  * Part II (15 mins, in two parts):* Once the patents have been cleaned and normalized, they can be turned into data structures that we can use to evaluate their relationship to other documents. This is done in two ways - by modeling each patent as a document vector and a graph node. 
  * Part IIA (7 mins): Patents as document vectors.* Once we have a patent as a data structure, we can treat the patent as a vector in an n-dimensional space. In moving from a document into a vector space, we will touch on normalization, stemming, TF/IDF, Latent Semantic Indexing (LSI) and Latent Dirichlet Allocation (LDA). 
  * Part IIB (7 mins): Patents as technology graphs.* This will show building graph structures using the connections between patents - both the built-in connections in the patents themselves as well as the connections discovered while working with the patents as vectors. We apply some social network analysis to partition the patent graph and find other documents in the same technology space. 
  * Part III (5 mins): What have we built?* Now that we have done all this analysis, we can see some interesting things about the patent database as a whole. How does the patent database act as a map to the world of technology? And how has this helped with the original problem - finding better prior art?

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Van Lindberg</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/425/pycon-2011--how-to-kill-a-patent-with-python</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/425_how-to-kill-a-patent-with-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011HowToKillAPatentWithPython889.png"></media:thumbnail></item><item><title>How to sell Python</title><link>http://www.pyvideo.org/video/378/pycon-2011--how-to-sell-python</link><description>&lt;p&gt;Description&lt;/p&gt;
How to sell Python

Presented by Daniel Greenfeld , C. Titus Brown , Dan Mesh , Chris Shenton ,
Rich Leland , Frank Wiles

A lot of people want to use Python, but their customer, management, school,
government, or organization won't let them. Python is a great tool, but it can
be challenging to get in the door. This panel will explore how companies and
individuals have successfully introduced Python, what tools are available to
sell Python, and what pitfalls there are to avoid.

Abstract

A lot of people want to use Python, but their customer, management, school,
government, or organization won't let them. Python is a great tool, but it can
be challenging to get in the door. This panel will explore how companies and
individuals have successfully introduced Python, what tools are available to
sell Python, and what pitfalls there are to avoid.

Possible questions will include:

  * What is a good example success story you can share? 
  * What pitfalls should you avoid? 
  * How do you deal with organizations that have already spent bucketloads of money on a piss-poor technology stack, are hurting for it, but can't seem to let go? 
  * How do you fight Fear-Uncertainty-Doubt (FUD) spread by people who stand to lose from introducing Python? 
  * What tools are available to help sell Python? 

Five panelists will be chosen from a broad spectrum of individuals including
academic, government, for-profit organizations, and non-profit organizations.

Speakers:

  * Academia: C. Titus Brown 
  * Goverment: Chris Shenton of Koansys/NASA 
  * Large Commercial Organization: Dan Mesh of Evite 
  * Small Commercial Organization: Frank Wiles of RevSys 
  * Non-Profit Organization: Rich Leland of National Geographic 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Shenton,C. Titus Brown,Daniel Greenfeld,Dan Mesh,Frank Wiles,Rich Leland</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/378/pycon-2011--how-to-sell-python</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/378_how-to-sell-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011HowToSellPython286.png"></media:thumbnail></item><item><title>How to write obfuscated python</title><link>http://www.pyvideo.org/video/398/pycon-2011--how-to-write-obfuscated-python</link><description>&lt;p&gt;Description&lt;/p&gt;
How to write obfuscated python

Presented by Rev. Johnny Healey

With its clean, highly readable syntax, Python would seem to be quite a
challenge for a programmer attempting to write obfuscated code. Fortunately,
it provides a wide variety of high-level abstractions that can be misused in
exciting ways. This survey of obfuscation strategies will include topics such
as decorator abuse, lambda calculus, and bytecode manipulation.

Abstract

Python's clean syntax can make traditional approaches to writing obfuscated
code much more challenging. Fortunately, Python provides many useful
abstractions that can be misused to write code that is unreadable or even
deliberately misleading. This talk will provide a survey of silly python
tricks that explore the boundaries of the language.

Topics

  * Redefining builtins 
  * Rarely used syntax 
  * Comparison edge cases 
  * Things you probably shouldn't do with decorators 
  * Fun with lambdas 
  * Bytecode manipulation 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rev. Johnny Healey</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/398/pycon-2011--how-to-write-obfuscated-python</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/398_how-to-write-obfuscated-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011HowToWriteObfuscatedPython160.png"></media:thumbnail></item><item><title>HTSQL - an insanely good WSGI / REST interface to your favorite database</title><link>http://www.pyvideo.org/video/365/pycon-2011--htsql---an-insanely-good-wsgi---rest-</link><description>&lt;p&gt;Abstract&lt;/p&gt;
HTSQL is a URI-based high-level query language for relational databases; it is
written in the Python language. HTSQL is a wonderful complement existing WSGI-
based applications, making it trivial to create interactive dashboards,
complex reports. We use HTSQL as a REST query interface for data integration
and ad-hoc reporting by technical users or ``accidental programmers``.


&lt;p&gt;Description&lt;/p&gt;
The HTSQL processor is a high-level URI-based query language for relational
databases such as SQLite, PostgreSQL or MySQL. Since it's written in Python,
it is easy to integrate and generates immediate value as the core of your
application's custom reporting engine. HTSQL is like the Django or SQLAlchemy
ORMs in that it generates SQL, but unlike an ORM in that its design center is
completely different -- it was created for hard core reporting and not object
to relational mapping. Hence, it is a wonderful complement to existing WSGI-
based applications to easily create dashboards, complex reports. We use HTSQL
as a REST reporting interface for data integration and ad-hoc queries.

This talk will have two parts. In the first part we'll give a brief overview
of the rationale and design of the query language. In the second part, we'll
show how to hook the HTSQL processor into your WSGI application and how to
make custom commands, such as a simple calendar output from a table containing
a date column.

The talk will be presented by Clark Evans, HTSQL was developed by Kyrylo
Simonov. The main HTSQL site is [http://htsql.org](http://htsql.org) and the
code is at [http://bitbucket.org/prometheus/htsql](http://bitbucket.org/promet
heus/htsql). It'll be similar to previous talks, such as
[http://htsql.org/talks/20101103.html](http://htsql.org/talks/20101103.html).

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Clark C. Evans</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/365/pycon-2011--htsql---an-insanely-good-wsgi---rest-</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/365_htsql-an-insanely-good-wsgi-rest-interface-to-your-favorite-database.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011HTSQLAnInsanelyGoodWSGIRESTInterfaceToYour159.png"></media:thumbnail></item><item><title>HTTP in Python: which library for what task?</title><link>http://www.pyvideo.org/video/439/pycon-2011--http-in-python--which-library-for-wha</link><description>&lt;p&gt;Description&lt;/p&gt;
HTTP in Python: which library for what task?

Presented by Augie Fackler

HTTP is the lingua franca of the web, and many things done in Python depend on
it, yet HTTP in Python isn't always as good as one would expect. It's well
worth knowing the options and tradeoffs available.

Abstract

HTTP in Python is very much a mixed bag of available technology. What's
implemented mostly works well, but there are some frustrating gaps in
different libraries that are poorly documented. I've gone wading through every
HTTP library I can find for Python while trying to fix an obscure bug in
Mercurial and decided to write my own. I'll cover what's available today and
why I'm starting from scratch with a completely new implementation.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Augie Fackler</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/439/pycon-2011--http-in-python--which-library-for-wha</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/439_http-in-python-which-library-for-what-task.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011HTTPInPythonWhichLibraryForWhatTask758.png"></media:thumbnail></item><item><title>Introduction to Parallel Computing on an NVIDIA GPU using PyCUDA</title><link>http://www.pyvideo.org/video/436/pycon-2011--introduction-to-parallel-computing-on</link><description>&lt;p&gt;Description&lt;/p&gt;
Introduction to Parallel Computing on an NVIDIA GPU using PyCUDA

Presented by Roy Hyunjin Han

With Andreas Klöckner's PyCUDA, you can harness the massively parallel
supercomputing power of your NVIDIA graphics card to crunch numerically
intensive scientific computing applications in a fraction of the runtime it
would take on a CPU and at a fraction of the development cost of C++. We'll
cover hardware architecture, API fundamentals and several examples to get you
started.

Abstract

There are two approaches to parallelizing a computationally heavy procedure:
use a messaging queue such as AMQP to distribute tasks among a networked
cluster or increase the number of processors in a single machine. This talk
focuses on techniques for adapting mathematical code to run on specialized
multi-core graphic processors.

Modern graphic processors have hard-coded transistors for common vector and
matrix operations, making them ideal for general scientific computing.
However, the NVIDIA CUDA's unique design requires knowledge of its hardware to
adapt algorithms effectively. This talk covers basic CUDA architecture, API
functions and several examples to illustrate the different kinds of problems
that will benefit from parallelization.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Roy Hyunjin Han</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/436/pycon-2011--introduction-to-parallel-computing-on</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/436_introduction-to-parallel-computing-on-an-nvidia-gpu-using-pycuda.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011IntroductionToParallelComputingOnAnNVIDIAGPUU724.png"></media:thumbnail></item><item><title>Javascript for people who know Python</title><link>http://www.pyvideo.org/video/383/pycon-2011--javascript-for-people-who-know-python</link><description>&lt;p&gt;Description&lt;/p&gt;
Javascript for people who know Python

Presented by Ian Bicking

Javascript as a diff on Python.

Abstract

You know Python. You should know Javascript. The two aren't so different, but
this talk will explain exactly how they are different -- lists, dicts,
objects, functions, loops and all the other details of Javascript described in
terms of Python.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Ian Bicking</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/383/pycon-2011--javascript-for-people-who-know-python</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/383_javascript-for-people-who-know-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011JavascriptForPeopleWhoKnowPython724.png"></media:thumbnail></item><item><title>Jython Concurrency</title><link>http://www.pyvideo.org/video/388/pycon-2011--jython-concurrency</link><description>&lt;p&gt;Description&lt;/p&gt;
Jython Concurrency

Presented by Jim Baker

Jython is arguably the best Python implementation to target concurrent code.
Jython has no GIL, it leverages the Java platform to provide robust support
for concurrency in its runtime, and it enables access to a set of high-level
abstractions from Java. This talk will walk through at the extreme level
pertinent Jython implementation details and a series of examples, including
Java integration.

Abstract

Jython implements the Python language, but we leverage the underlying Java
platform to provide an opionated alternative to CPython in our support of
concurrency.

Because of the GIL and related infrastructure, CPython cannot use a model in
which threads perform concurrent computation defined in Python on shared
objects in the same process. (Of course, there are workarounds, such as
multiprocessing or using C extensions.)

In contrast, there's no GIL in Jython. Jython instead embraces threads,
provides extensive support for managing their execution and coordination
through standard Java platform functionality (java.util.concurrent), and
threaded code works well with Jython's implementation of standard mutable
collection types. Lastly, the underlying JVM provides extensive
instrumentation as well as the ability to set a variety of parameters,
including choice of GC. There are also the inevitable pitfalls that might be
seen in complex architectures, such as around the use of ClassLoaders.

This talk will go into a detailed discussion of some of the interesting
ramifications of these design points and how they can be effectively applied
to write concurrent code, as illustrated through a variety of short examples.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jim Baker</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/388/pycon-2011--jython-concurrency</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/388_jython-concurrency.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011JythonConcurrency940.png"></media:thumbnail></item><item><title>Large Scale Data Conditioning &amp;amp; Processing with Stackless Python and Pypes</title><link>http://www.pyvideo.org/video/400/pycon-2011--large-scale-data-conditioning--amp--p</link><description>&lt;p&gt;Description&lt;/p&gt;
Large Scale Data Conditioning &amp; Processing with Stackless Python and Pypes

Presented by Eric Gaumer

Pypes is a component oriented framework for designing dataflow applications.
It uses Stackless Python to model components as computational entities that
operate by sending and receiving messages. Components are designed to process
streams of data modeled as a series of messages which are exchanged
asynchronously. Data streams are initiated over an asynchronous REST
interface.

Abstract

There's been some recent momentum around data flow programming with a number
of new frameworks having been released. This new found interest is due largely
in part to the increasing amount of data being produced and consumed by
applications. MapReduce has become a general topic of discussion for analytics
over large data sets but it's increasingly evident that it's not a panacea.

Simple batch processing tools like MapReduce and Hadoop are just not powerful
enough in any one of the dimensions of the big data space that really matters.
One particular area where MapReduce falls short is in near real-time search.
It used to be common to run batch processing jobs on a nightly basis which
would index the days events, making them searchable.

Given today's social dynamics, people have come to expect instant access to
data as opposed to a daily digest. Batch oriented semantics are being
superseded by event driven architectures that act on live, real-time streams
of data. This shift in paradigm has sparked new interest in dataflow concepts.

Dataflow frameworks promote the data to become the main concept behind any
program. It becomes a matter of "data-flow" over "control-flow" where
processes are just the way data is created, manipulated and destroyed. This
concept is well represented in the Unix operating system which pipes data
between small single-purpose tools to produce more sophisticated applications.

Pypes is a dataflow framework that leverages Stackless Python to model
processes as black box operations that communicate by sending and receiving
messages. These processes are naturally component oriented allowing them to be
connected in different ways to form new applications. Components are
inherently stateless making parallel processing relatively simple. Because a
component is an abstraction of a Stackless tasklet (true coroutines),
expensive setups such as loading machine learning models are done once during
initialization and can then be used throughout the life of the component. This
is in contrast to MapReduce frameworks that typically incur this overhead each
time the map function is called or try to manage some sort of global state.

One aspect that differentiates Pypes from other dataflow frameworks is its
"push" model. Unlike generator based solutions which pull data through the
system, Pypes provides a RESTful interface that allows data to be pushed in.
This allows Pypes to sit more natural as an event driven middleware component
in the context of a larger architecture. A data push model also simplifies
scalability since an entire cluster of nodes can be setup behind a load
balancer which will then automatically partition the incoming data stream.
Generator based "pull models" cannot easily partition data without somehow
coordinating access to the data which involves global state.

Pypes was designed to be a highly scalable, event driven, dataflow scheduling
and execution environment. Writing your own components is simple and Pypes
provides Paste templates for creating new projects. Components are packaged as
Python eggs and discovered automatically. They can be wired together using a
visual editor that runs in any HTML5 compliant browser. Pypes supports
Directed Acyclic Graphs and data streams are modeled as a series of JSON
(dict) packets which support meta-data at both the packet level and the field
level.

Pypes also leverages the Python multiprocessing module to scale up. Data
arriving through the REST interface on any given node will be distributed
across parallel instances of the graph running on different cores/CPUs. Data
submission is completely asynchronous.

This talk will provide a gentle introduction to the Pypes architecture and
design.

Outline:

  * Brief intro to Stackless Python (benefits it provides) 
  * Control-Flow vs Data-Flow 
  * Preemptive vs Cooperative Scheduling 
  * The Topological Scheduler 
  * The REST API (Submitting Data - Asynchronous Web Service) 
  * Packet API: A unified data model with meta-data support 
  * Writing Custom Components - Paste templates and pluggable eggs 
  * Scale up - multiprocessing support 
  * Scale out - cloud friendly 
  * Questions 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Eric Gaumer</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/400/pycon-2011--large-scale-data-conditioning--amp--p</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/400_large-scale-data-conditioning-amp-processing-with-stackless-python-and-pypes.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011LargeScaleDataConditioningProcessingWithStackl439.png"></media:thumbnail></item><item><title>Linguistics of Twitter</title><link>http://www.pyvideo.org/video/363/pycon-2011--linguistics-of-twitter</link><description>&lt;p&gt;Abstract&lt;/p&gt;
Dialectical changes in America are influencing expression online. This talk
will discuss a current project which is using the Natural Language Toolkit to
develop up to date reference materials to measure and monitor online natural
language.


&lt;p&gt;Description&lt;/p&gt;
Contrary to expectations, the prevalence of television did not cause every
American to speak in a common standard dialect. Rather, smaller sub-regional
dialects are merging into stronger regional dialects with the largest change
in spoken English since the 1750's taking place in the Northern Cities Vowel
Shift.

Social Media is widely considered a conversational media, users often leaning
on their dialect which to express themselves.

Taking a recent tweet for example:

    
    '_andBeautyKills: – after tonight, don’t leave your boy roun’ me, umma #true playa fareal.'

This tweet presents a problem for traditional natural language processing
paradigm:

  * Do they build out an extensive reg ex to solve this? 
  * Even Worse, do they reject it because of non-Standard English? 
  * How do they respond such that communication is effective? 

Currently under development with Python using the Natural Language Toolkit are
the tools and methodologies to process, understand and respond to
communication that falls outside Standard American English. This talk will
focus on the status of existing tools, where development stands, challenges
for traditional tools and potential opportunities for exploration.

While limited to American English, any participant who is studying natural
language processing of any language is welcome and sure to learn. The
techniques could be applied to languages around the world for which the
motivated programmer is knowledgeable about.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael D. Healy</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/363/pycon-2011--linguistics-of-twitter</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/363_linguistics-of-twitter.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011LinguisticsOfTwitter909.png"></media:thumbnail></item><item><title>MongoDB + Pylons at Catch.com: Scalable Web Apps with Python and NoSQL</title><link>http://www.pyvideo.org/video/399/pycon-2011--mongodb---pylons-at-catch-com--scalab</link><description>&lt;p&gt;Description&lt;/p&gt;
MongoDB + Pylons at Catch.com: Scalable Web Apps with Python and NoSQL

Presented by Niall O'Higgins

The Catch.com backend provides an API for publishing and querying your
personal data - used by many hugely popular Android, iOS and Web clients. We
ported this system to Python and MongoDB, using the Pylons Web framework. This
talk details our reasoning for choosing - and experiences with - these
cutting-edge Web and NoSQL database technologies in a high-traffic, real-world
production system.

Abstract

Faced with the limits of our initial Catch.com Java/BDB backend implemention,
we evaluated various alternative technologies including Amazon SimpleDB,
MySQL, Cassandra and MongoDB. Eventually we settled on Python, Pylons and
MongoDB.

We found Python and MongoDB gave us unique flexibility with our data model,
allowed us to scale for increased reliability and performance and decreased
feature development time - and in this talk we'll describe exactly how.

While there are many advantages, Python/Pylons and MongoDB (as a relative
newcomer on the database scene) certainly have issues and limitations which
must be taken into careful consideration for any real-world production
deployment.

We compare MongoDB with other database technologies such as more traditional
RDBMS like MySQL and competing NoSQL options such as Cassandra, CouchDB and
BDB.

We give a detailed introducton to data modeling in MongoDB - with special
attention paid to how this differs from a traditional relational system - the
operators provided by its rich query language and utilizing advanced features
such as GeoSpatial indexing, Replica Sets, Sharding - and how to deal with
some of the more publicized limitations of the system (such as single-server
durability).

While much of this talk will be about using MongoDB with Python, we will also
touch on issues surrounding production deployment of the Pylons Web framework,
including how we work around the GIL to take advantage of multi-core machines.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Niall O'Higgins</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/399/pycon-2011--mongodb---pylons-at-catch-com--scalab</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/399_mongodb-pylons-at-catch-com-scalable-web-apps-with-python-and-nosql.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011MongoDBPylonsAtCatchcomScalableWebAppsWithPy842-535.jpg"></media:thumbnail></item><item><title>Montreal-Python -- Lessons Learned from Bootstraping a Python Community</title><link>http://www.pyvideo.org/video/361/pycon-2011--montreal-python----lessons-learned-fr</link><description>&lt;p&gt;Abstract&lt;/p&gt;
Montréal-Python is a user-group formed in 2007. It has since then grown into a
thriving community with code sprint and regular meetings attracting over 50
attendees. This talk will present history of the group and will highlight the
key factors behind its success with the hope to inspire others to replicate
that accomplishment.


&lt;p&gt;Description&lt;/p&gt;
The talk will first walk the audience through the factors inherent to Montréal
itself and how it affected other user groups before Montréal-Python. These
groups inspired us to get a group of Python hackers started the presentation
will show how we were able to leverage on the success of other user groups to
bring our young community forward.

The various stages of our growth will be presented along with insights on how
we managed to find speakers and venues at each point. The presentation will
then go through an overview of our current activities, sharing in the process
how effective they are in engaging the community. Our plans for the next few
years will be presented then a summary will provide advice to anyone who would
like to get started organizing a local Python user group.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Yannick Gingras</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/361/pycon-2011--montreal-python----lessons-learned-fr</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/361_montreal-python-lessons-learned-from-bootstraping-a-python-community.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011MontrealPythonLessonsLearnedFromBootstrapingAP942.png"></media:thumbnail></item><item><title>mrjob: Distributed Computing for Everyone</title><link>http://www.pyvideo.org/video/404/pycon-2011--mrjob--distributed-computing-for-ever</link><description>&lt;p&gt;Description&lt;/p&gt;
mrjob: Distributed Computing for Everyone

Presented by Jimmy Retzlaff

Have tons of data that needs analysis? Now it's as easy as 1-2-3! 1) Sign up
for an Amazon Web Services account. 2) Install Yelp's mrjob. 3) Write as few
as a dozen lines of Python code. This talk will show you how to use mrjob and
Amazon's Elastic MapReduce to easily process lots of data in parallel on a
potentially large cluster of computers that you can rent for a dime per
computer per hour.

Abstract

In their 2004 paper, Google outlined MapReduce - one of the programming models
they use to process large data sets. MapReduce is a relatively simple model to
develop for that allows the underlying framework to automatically parallelize
the job, add fault tolerance, and scale the job to many commodity computers.

In 2009, Amazon Web Services introduced their Elastic MapReduce (EMR) product.
It layers the Hadoop open source package on top of their Elastic Compute Cloud
(EC2) to allow anyone to rent a cluster of computers by the hour, starting at
about a dime per computer per hour, in order to run MapReduce jobs.

Some of the significant issues with Amazon's solution involve starting up
machine instances, replicating your code and its dependancies to EMR, running
and monitoring the job, and gathering the results.

So Yelp developed mrjob, which takes care of these details and lets the
developer focus on working with their data. Yelp uses mrjob to power many
internal jobs that work with its very large log files, for example:

  * People Who Viewed This Also Viewed... 
  * A user clicked an ad over and over, but we only want to charge the advertiser once 
  * We're thinking of a change, but want to simulate how that will affect ad revenue 

Now you can use that same power with just a few lines of Python.

Useful links:

  * Install mrjob: sudo easy_install mrjob 
  * Documentation: [http://packages.python.org/mrjob/](http://packages.python.org/mrjob/)
  * PyPI: [http://pypi.python.org/pypi/mrjob](http://pypi.python.org/pypi/mrjob)
  * Development is hosted at github: [http://github.com/Yelp/mrjob](http://github.com/Yelp/mrjob)

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jimmy Retzlaff</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/404/pycon-2011--mrjob--distributed-computing-for-ever</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/404_mrjob-distributed-computing-for-everyone.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011MrjobDistributedComputingForEveryone940.png"></media:thumbnail></item><item><title>Opening the Flask</title><link>http://www.pyvideo.org/video/440/pycon-2011--opening-the-flask</link><description>&lt;p&gt;Description&lt;/p&gt;
Opening the Flask

Presented by Armin Ronacher

After a year of the Flask microframework it's time to draw some conclusions,
see things that went right and things that should be improved. The talk gives
both an introduction into Flask itself as well as well as the ecosystem that
evolved around it.

Abstract

Flask is a microframework that was born out of an April's fool joke that
quickly became more than that. Based on the powerful foundation of Werkzeug
and Jinja2 it's one of the most popular frameworks for Python now.

The talk starts with a very quick introduction into Flask, where it all
started and why I think people like it. We will look into the design of Flask
and why it works the way it works.

Furthermore we will look into the Flask ecosystem and how extensions work and
have a brief look in what is planned for the future, especially regarding
Python 3.

The talk assumes basic knowledge of web applications.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Armin Ronacher</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/440/pycon-2011--opening-the-flask</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/440_opening-the-flask.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011OpeningTheFlask360.png"></media:thumbnail></item><item><title>Optimal Aircraft Engine Tuner Selection in Python</title><link>http://www.pyvideo.org/video/380/pycon-2011--optimal-aircraft-engine-tuner-selecti</link><description>&lt;p&gt;Description&lt;/p&gt;
Optimal Aircraft Engine Tuner Selection in Python

Presented by Jeffrey Armstrong

A numerical algorithm for designing on-board aircraft engine diagnostics has
been implemented in Python. Employing the optimization techniques within
SciPy, the code performs a search for an optimal vector of parameters for
estimating engine variables, including exhaust temperatures and thrust. The
algorithm exploits the numerical strengths of Python and SciPy for speed and
interoperability.

Abstract

An emerging field of aircraft engine diagnostics is the inclusion of on-board
engine performance tracking algorithms. These algorithms utilize data provided
by a limited number of engine sensors to determine the current engine
performance, which tends to degrade over time. However, estimating engine
performance instantaneously is problematic due to the limited number of
sensors normally available on a commercial aircraft engine.

One common practice is to estimate and track engine performance in software
using a Kalman filter, a mathematical construct for tuning a numerical model
to better track actual measurements (1). A new technique has been devised to
optimize the design of this filter in aircraft engine applications (2). An
optimization procedure to aid in the design of the filter has been implemented
in Python and exercised against the significant number of minimization and
optimization strategies available in SciPy. The talk focuses on the design of
this optimization procedure in Python. The object-oriented nature of Python
offers benefits over alternative numerical languages; speed, availability, and
maintainability played central roles in the selection of Python as the
implementation language. The availability of the multiprocessing module
allowed for full utilization of modern multi-core CPUs, in contrast with often
limited commercial numerical computing packages, further improving
computational speed.

Some difficulties were encountered during this design exercise. Discussion of
these obstacles and their eventual solution is presented. Specifically,
iterative solvers for the discrete algebraic Riccati equation and the discrete
Lyapunov equation had to be authored in Python (3,4). Additional framework for
working with discrete state-space control systems was created, exploiting the
object-oriented features of the language (5).

The Python implementation was able to verify the solution of the optimization
problem. Comparison with an alternative, reference MATLAB implementation will
be presented briefly. The results of this research is planned to be presented
at the American Society for Mechanical Engineers Turbo Expo 2011 Conference in
June, 2011 (6). The algorithm design in Python is meant to showcase the
ability to perform controls engineering tasks in the Python language
efficiently.

1. “Kalman Filter,” Wikipedia: [http://en.wikipedia.org/wiki/Kalman_filter](ht
tp://en.wikipedia.org/wiki/Kalman_filter)

2. Simon, D. L. and Garg, S., “Optimal Tuner Selection for Kalman Filter-Based
Aircraft Engine Performance Estimation”. Journal of Engineering for Gas
Turbines and Power. March 2010, Vol. 132.

3. “Algebraic Riccati Equation,” Wikipedia: [http://en.wikipedia.org/wiki/Alge
braic_Riccati_equation](http://en.wikipedia.org/wiki/Algebraic_Riccati_equatio
n)

4. “Lyapunov Equation,” Wikipedia: [http://en.wikipedia.org/wiki/Lyapunov_equa
tion](http://en.wikipedia.org/wiki/Lyapunov_equation)

5. “State Space,” Wikipedia: [http://en.wikipedia.org/wiki/State-
space](http://en.wikipedia.org/wiki/State-space)

6. Simon, D. L., Armstrong, J. B., "Application of an Optimal Tuner Selection
Approach for On-Board Self-Tuning Engine Models," Proceedings of the ASME
Turbo Expo 2011, GT2011-46408, 2011 (To Be Published).

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey Armstrong</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/380/pycon-2011--optimal-aircraft-engine-tuner-selecti</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/380_optimal-aircraft-engine-tuner-selection-in-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011OptimalAircraftEngineTunerSelectionInPython133-714.jpg"></media:thumbnail></item><item><title>Packaging, from Distutils to Distutils2</title><link>http://www.pyvideo.org/video/409/pycon-2011--packaging--from-distutils-to-distutil</link><description>&lt;p&gt;Description&lt;/p&gt;
Packaging, from Distutils to Distutils2

Tarek Ziadé

Packaging or installing a Python application can be extremely painful. This
talk will deep-dive into the new Distutils2 features and explain how you can
use them in your project *today* to make life easier for everyone (users, OS
package managers, developers, etc.).

Abstract

  1. Distutils2 presentation and goals 
    1. Framework 
    2. Command-driven packaging system 
    3. Changes from Distutils1 
      1. R.I.P. setup.py 
      2. The new metadata fields (PEP 345) 
      3. versions for your project (PEP 386) 
      4. PyPI goodies 
        1. browsing 
        2. uploading docs 
      5. What's installed ? what to install ? (PEP 376) 
        1. The Dependency graph tool 
      6. Extensibility ! 
        1. commands 
        2. compilers 
    4. Pysetup, one command to rule them all 
      1. install ! 
      2. remove 
      3. do other things 
    5. Examples 
      1. Example 1: A simple Distutils2 project 
      2. Example 2: Porting your project to Distutils2, and keep it working in Distutils/Setuptools/zc.buildout environments. 
      3. Example 3: Creating and releasing your own commands and compilers 
      4. Example 4: Developement process made simple with Distutils2 
    6. Conclusion 
      1. Roadmap 

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/409/pycon-2011--packaging--from-distutils-to-distutil</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/409_packaging-from-distutils-to-distutils2.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PackagingFromDistutilsToDistutils2901.png"></media:thumbnail></item><item><title>Panel: Python in Schools: Teaching It and Teaching With It.</title><link>http://www.pyvideo.org/video/437/pycon-2011--panel--python-in-schools--teaching-it</link><description>&lt;p&gt;Description&lt;/p&gt;
Panel: Python in Schools: Teaching It and Teaching With It.

Panel with Joel Zachary Miller, Jeffrey Elkner, Vern Ceder, Brian C. Brumley,
Maria Litvin

Educators discuss Python as both a subject and a tool in primary and secondary
(K12) education. Topics addressed include the distinction between teaching
Python and teaching with Python, the benefits of Python in K12 and ways to
demonstrate the value of Python to administrators. Panel includes private and
public K12 educators and university faculty involved in instruction in the K12
setting.

Abstract

Zac Miller will act as panel moderator.

Panel will open with a brief introduction of the origins of the panel and self
introductions of panel members before addressing the following topics:

  * The distinction between teaching Python and teaching with Python. 
    * Teaching Python 
    * Teaching Math with Python 
  * How does Teaching with Python complement Teaching Python? 
    * Do tensions between the two exist? 
  * What keeps Python out of schools? What can be done to encourage more schools to teach tools like Python? 
  * What is the biggest benefit teaching Python brings to your school and students? What is the biggest benefit in general, beyond your school? 
  * Can teaching Python help spark creativity in those students who have trouble exercising it? 
    * When teaching Python a creativity divide becomes readily apparent among students. Students with a high level of curiosity and creativity constantly try new things on their own, while other students are focused solely on completing the assignments for grades. How can an instructor handle this? 
    * What tangible steps can an instructor take to encourage creativity? 
  * What does the future look like for Python in K12 education, both at our own schools and in general? 
  * Audience Questions 

Panel Biographies:

Vern Ceder, Director of Technology, Canterbury School, Ft Wayne, Indiana. The
Canterbury School has been teaching at least a little Python to every single
8th and 9th grader in the school since 2001, as well as offering electives in
Python, Java, C, etc. Vern also teaches Python through Northwestern's Gifted
Learning Links program
([http://www.ctd.northwestern.edu/gll/](http://www.ctd.northwestern.edu/gll/))
and is the author of The Quick Python Book, 2nd ed
([http://www.manning.com/ceder](http://www.manning.com/ceder))

Maria Litvin. Maria teaches Math and Computer Science at Phillips Academy in
Andover, MA, including "Introduction to Discrete Mathematics and Programming
in Python." She also taught Python to Boston-area high school teachers and to
middle schoolers in Google's CAPE program. She's co-author of several Computer
Science textbooks, most recently Mathematics for the Digital Age and
Programming in Python ([www.skylit.com/mathandpython.html](http://www.skylit.c
om/mathandpython.html)).

Jeffrey Elkner, teaches computer programming and information technology at the
Governor's Career and Technical Academy in Arlington, Virginia. He has been
teaching with Python since 1999, and is co-author of a free on-line textbook:
How to Think Like a Computer Scientist: Learning with Python. He also
maintains the Open Book Project
([http://openbookproject.net](http://openbookproject.net/)), which contains
several Python resources. Jeff has attended each PyCon held thus far, often
bringing students along with him.

Brian Brumley teaches Python (and lots of other stuff) to grades 6-8 at
Porter-Gaud school in Charleston, SC. Brian is a regular presenter at state
and regional conferences on technology and programming in schools.

Zac Miller is adjunct instructor in the STEM school at Gainesville State
College and a faculty member at the Da Vinci Academy at South Hall Middle
School in Gainesville, Georgia. Zac is currently teaching Python programming
and Python programming for Geographic Information Systems to K12 and college-
level students.

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/437/pycon-2011--panel--python-in-schools--teaching-it</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/437_panel-python-in-schools-teaching-it-and-teaching-with-it.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PanelPythonInSchoolsTeachingItAndTeachingWith796.png"></media:thumbnail></item><item><title>Panel: Python VMs</title><link>http://www.pyvideo.org/video/421/panel-python-vms</link><description>&lt;p&gt;Description&lt;/p&gt;
Panel: Python VMs

Presented by Jacob Kaplan-Moss, Brett Cannon, Maciej Fijalkowski, Frank
Wierzbicki, Dino Viehland

Python is lucky enough to have a healthy ecosystem of virtual machines (VMs)
exist. CPython, Jython, IronPython, and PyPy are all used extensively by
people in real-world situations. This panel brings together a representative
from each of the major VMs to discuss where they are now, going in the future,
and to answer questions from the community.

Abstract

All four major Python VMs will be represented:

  * [CPython](http://python.org/): Brett Cannon 
  * [Jython](http://www.jython.org/): Frank Wierzbicki 
  * [IronPython](http://ironpython.net/): Dino Viehland 
  * [PyPy](http://pypy.org/): Maciej Fijalkowski 
Moderation will be handled by Jacob Kaplan-Moss of Django.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Brett Cannon,Dino Viehland,Frank J Wierzbicki,Jacob Kaplan-Moss,Maciej Fijalkowski</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/421/panel-python-vms</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/421_panel-python-vms.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PanelPythonVMs871.png"></media:thumbnail></item><item><title>Pluggable Django Patterns</title><link>http://www.pyvideo.org/video/379/pycon-2011--pluggable-django-patterns</link><description>&lt;p&gt;Description&lt;/p&gt;
Pluggable Django Patterns

Presented by Corey Oordt

Pluggable or reusable applications are a key feature of Django, but there is
little guidance on writing them well. We'll dig into the different types of
Django applications and coding patterns that make writing a reusable
application easier. The talk also covers ways to avoid common implementation
gotchas.

Abstract

Reusable, or pluggable, applications are a powerful feature of Django. Your
code can do more if written with a few ideas and techniques in mind. We'll
cover:

  * The four qualities of a pluggable application 
  * The three types of Django applications 
  * Ten common situations in implementing reusable code and coding patterns to handle them 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Corey Oordt</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/379/pycon-2011--pluggable-django-patterns</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/379_pluggable-django-patterns.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PluggableDjangoPatterns674.png"></media:thumbnail></item><item><title>Prototyping Go's Select with stackless.py for Stackless Python</title><link>http://www.pyvideo.org/video/438/pycon-2011--prototyping-go--39-s-select-with-stac</link><description>&lt;p&gt;Description&lt;/p&gt;
Prototyping Go's Select with stackless.py for Stackless Python

Presented by Andrew Francis

Showing how to use Python to prototype powerful concurrency features for
Stackless Python. We do want you to try this at home.

Abstract

Google’s introduction of the Go language raised eyebrows in the Stackless
Python community. Although very different languages, Go and Stackless Python’s
concurrency model share a common ancestor: the Bell Labs family of languages
(i.e., Newsqueak, Limbo). The common feature are channels: a synchronous
message passing mechanism based on Tony Hoare’s Communicating Sequential
Processes (CSP).

Both Go and Python have channels. However with the select language statement,
Go has the ability to wait on multiple channels simultaneously. Select greatly
simplifies many concurrent programming problems. Stackless Python does not
have this feature. Other channel based languages also feature powerful
concurrency constructs. How hard would these constructs be to implement for
Stackless Python?

This talk explores the prototyping potential of stackless.py, the PyPy's
framework's implementation of Stackless Python. The beauty of stackless.py is
that it is written in Python and implements much of Stackless Python's API!
The "case study" involves prototyping Go's select in stackless.py before
reimplementing select in C based Stackless Python.

During this talk, it will be shown how stackless.py can be used with CPython
and the greenlet package (no need to install another Python). The audience
will also get an in depth look at how channels are implemented. Channels are
at the heart of Stackless Python's message based concurrency model. Finally
the audience will gain insights into future directions of Stackless Python.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Andrew Francis</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/438/pycon-2011--prototyping-go--39-s-select-with-stac</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/438_prototyping-go-s-select-with-stackless-py-for-stackless-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PrototypingGosSelectWithStacklesspyForStackless735.png"></media:thumbnail></item><item><title>PSF funds PyPy</title><link>http://www.pyvideo.org/video/355/pycon-2011--psf-funds-pypy</link><description>&lt;p&gt;Description&lt;/p&gt;
Maciej Fija?kowski, Armin Rigo, Alex Gaynor, Laura Creighton and Jacob Hall

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/355/pycon-2011--psf-funds-pypy</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/355_psf-funds-pypy.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PSFFundsPyPy160.png"></media:thumbnail></item><item><title>Python 3: the next generation is here already</title><link>http://www.pyvideo.org/video/375/python-3-the-next-generation-is-here-already</link><description>&lt;p&gt;Description&lt;/p&gt;
Python 3: the next generation is here already

Presented by wesley chun

This talk is about the evolution of Python. We will discuss Python 2 and
Python 3: what the compatibility issues are, what the main differences are,
and also talk about migration, Python 2.6/2.7, and other transition tools.

Abstract

Python is currently at a crossroads: Python 2 has taken it from a quiet word-
of-mouth language to primetime, with many companies around the world using it
and an ever-increasing global marketshare of the programming world. But now
comes Python 3, the first version of the language that is not backwards
compatible with previous releases.

What does this mean? Are all my Python programs going to break? Will I have to
rewrite everything? How much time do I have? When is Python 2 going to be
EOL'd? Is the language undergoing a complete rewrite and will I even recognize
it? What are the changes between Python 2 and 3 anyway? Also, the next
generation is already here, as Python 3 is over two years old now. What has
been ported so far, and what is its current status? Are migration plans or
transition tools available? If I want to start learning Python, should I do
Python 2 or Python 3? Are all Python 2 books obsolete?

We will attempt to answer all of these questions and more. Join us!

OUTLINE/TOPICS

  * Python 2 vs. Python 3 
  * Introduction to Python 3 
  * Backwards Compatibility 
  * Generational Changes 
  * Key Differences 
  * Role of Remaining Python 2.x releases 
  * Transition &amp; Migration Plans &amp; Tools 
  * Futures 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wesley J. Chun</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/375/python-3-the-next-generation-is-here-already</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/375_python-3-the-next-generation-is-here-already.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011Python3TheNextGenerationIsHereAlready624.png"></media:thumbnail></item><item><title>Python and Robots: Teaching Programming in High School</title><link>http://www.pyvideo.org/video/413/pycon-2011--python-and-robots--teaching-programmi</link><description>&lt;p&gt;Description&lt;/p&gt;
Python and Robots: Teaching Programming in High School

Presented by Vern Ceder

Combining Python with inexpensive robots is a very effective way of teaching
programming at the middle and high school levels. Since Python is easy to
understand a constructivist approach is possible - students learn by creating
and running simple programs, observing the results, and then modifying their
code to fix bugs and add functionality.

Abstract

The approach suggested in this talk is partly based upon that developed at the
Institute for Personal Robots in Education
([http://wiki.roboteducation.org](http://wiki.roboteducation.org/)) by staff
from Georgia Tech and Bryn Mawr, combined with my own experiences teaching
programming with Python as described in my talk "Goodbye, Hello World:
Rethinking Teaching with Python", PyCon 2007, and my subsequent talks at NECC.

Because students are able to see what their code is doing and because Python
is easy to understand, students can explore simple programming concepts,
learning features as they need them. This approach increases both student
engagement and retention. It also seems that this approach is more appealing
to girls than a more traditional programming class.

I'll illustrate my talk with samples of code created by students and video of
the students/robots in action.

Outline

Introduction - school background, course structure, origin of approach

Hardware and computer setup used

Initial exercises and first projects

  * Control of robot 
  * Program as sequence of commands 
  * Basic programming concepts - looping, branching, functions 

Advanced projects

    * obstacle detection 
    * image processing 
    * simple AI approaches 

Pitfalls and strategies for using robots

Questions and Suggestions

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Vern Ceder</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/413/pycon-2011--python-and-robots--teaching-programmi</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/413_python-and-robots-teaching-programming-in-high-school.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PythonAndRobotsTeachingProgrammingInHighSchool378.png"></media:thumbnail></item><item><title>Python-Aware Python</title><link>http://www.pyvideo.org/video/447/pycon-2011--python-aware-python</link><description>&lt;p&gt;Description&lt;/p&gt;
Python-Aware Python

Presented by Ned Batchelder

Python provides many features for introspecting, analyzing, parsing,
compiling, and otherwise grokking Python code. This talk will cover a number
of the techniques for writing Python-Aware Python, and will hopefully inspire
you to build the next great Python tool.

Abstract

Python provides many features for introspecting, analyzing, parsing,
compiling, and otherwise grokking Python code. These modules and techniques
provide the foundation for developer's tools such as autocompletion IDE's,
code analysis tools, test runners, profilers, and so on.

I'll delve into a number of the common techniques used to write Python-Aware
Python. Each has its area of applicability and its strengths and weaknesses.
I'll demonstrate small samples that show how those techniques underlie the
tools we all know and love.

The world of Python tools is ready for new exploration. This talk will give
you the foundation you need to write the next great Python-aware application.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Ned Batchelder</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/447/pycon-2011--python-aware-python</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/447_python-aware-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PythonAwarePython331.png"></media:thumbnail></item><item><title>Python for High Performance Computing</title><link>http://www.pyvideo.org/video/394/pycon-2011--python-for-high-performance-computing</link><description>&lt;p&gt;Description&lt;/p&gt;
Python for High Performance Computing

Presented by William Scullin

Python is becoming increasingly popular within the high performance computing
community. While it initially gained traction as a scripting language,
Python's role has continued to expand with Python applications for science
scaling to hundreds of thousands of cores and bindings to high performance
libraries becoming commonplace. This talk is meant as an overview of Python's
role in the HPC space.

Abstract

This talk is focused on raising awareness of Python in the high performance
computing space. Specific topics include:

  * building the Python interpreter for speed 
  * an overview of bindings to numerical libraries 
  * using GPUs and accelerators with Python 
  * scaling codes with MPI 
  * issues when scaling on very large systems 
  * an overview of successful science codes 
  * a live demonstration of Python running on 163,840 cores 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">William Scullin</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/394/pycon-2011--python-for-high-performance-computing</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/394_python-for-high-performance-computing.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PythonForHighPerformanceComputing720.png"></media:thumbnail></item><item><title>Python IDEs Panel</title><link>http://www.pyvideo.org/video/362/pycon-2011--python-ides-panel</link><description>&lt;p&gt;Description&lt;/p&gt;
Python IDEs Panel

Moderated by Michael Foord

  * Dino Viehland - Python Tools for Visual Studio 
  * Dmitry Jemerov - PyCharm 
  * Todd Whiteman - ActiveState Komodo IDE 
  * Stephan Deibel - WingWare IDE 
  * Barry Warsaw - Emacs 

As Python becomes more popular, more users are wanting IDEs that provide code
completion, integrated source code control, project management, and other
developer tools. This panel includes representatives from a number of Python-
specific or Python-supporting IDE vendors, showing the ways that IDEs can
speed up development on any platform.

Abstract

For many developers, IDEs are an essential tool-just as essential as source
code control. The growth of Python in recent years has led to a number of
projects and vendors developing Python-specific or Python-supporting IDEs.
This panel will allow attendees to compare and contrast the different IDEs
available.

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/362/pycon-2011--python-ides-panel</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/362_python-ides-panel.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PythonIDEsPanel405.png"></media:thumbnail></item><item><title>Python.MiroCommunity.org + UniversalSubtitles.org</title><link>http://www.pyvideo.org/video/356/pycon-2011--python-mirocommunity-org---universals</link><description>&lt;p&gt;Description&lt;/p&gt;
Will and Carl talk about Python Miro Community, where it's at now, the PSF
grant, and what they're planning for it in the future.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Carl Karsten,Will Kahn-Greene</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/356/pycon-2011--python-mirocommunity-org---universals</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/356_python-mirocommunity-org-universalsubtitles-org.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://s3.amazonaws.com/s3.mirocommunity.org/python/localtv/video_thumbs/4324/375x295.png"></media:thumbnail></item><item><title>Python Software Foundation Chairman Address</title><link>http://www.pyvideo.org/video/453/pycon-2011--python-software-foundation-chairman-a</link><description>&lt;p&gt;Description&lt;/p&gt;
Python Software Foundation Chairman Address

Presented by Steve Holden

Steven Holden summarizes the last year for the Python Software Foundation and
talks about future directions.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Steve Holden</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/453/pycon-2011--python-software-foundation-chairman-a</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/453_python-software-foundation-chairman-address.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PythonSoftwareFoundationChairmanAddress279.png"></media:thumbnail></item><item><title>Python - The Secret Sauce in the Open Cloud</title><link>http://www.pyvideo.org/video/372/pycon-2011--python---the-secret-sauce-in-the-open</link><description>&lt;p&gt;Description&lt;/p&gt;
Python - The Secret Sauce in the Open Cloud

Presented by Jason Huggins

This talk will go into detail on current cloud computing technology,
specifically OpenStack and libvirt and how Python is the "secret sauce" that
powers the open cloud. We'll show how to bring up your own cloud "from
scratch", and explain why you would do such a thing.

Abstract

Covered topics:

  * How to use VirtualBox 
  * How to use kvm 
  * How to use libvirt with Python 
  * How to check out, build, and deploy OpenStack 
  * How to setup and maintain your own cloud 
  * Real world examples 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jason Huggins</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/372/pycon-2011--python---the-secret-sauce-in-the-open</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/372_python-the-secret-sauce-in-the-open-cloud.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011PythonTheSecretSauceInTheOpenCloud789.png"></media:thumbnail></item><item><title>Rapid Python used on Big Data to Discover Human Genetic Variation</title><link>http://www.pyvideo.org/video/414/pycon-2011--rapid-python-used-on-big-data-to-disc</link><description>&lt;p&gt;Description&lt;/p&gt;
Rapid Python used on Big Data to Discover Human Genetic Variation

Presented by Deniz Kural

Advances in genome sequencing has enabled large-scale projects such as the
1000 Genomes Project to sequence genomes across diverse populations around the
world, resulting in very large data sets. I use Python for rapid development
of algorithms for processing &amp; analyzing genomes and discovering thousands of
new variants, including "Mobile Elements" that copy&amp;paste; themselves across
the genome.

Abstract

Recent advances in high-throughput sequencing now enables accurate sequencing
human genomes at a low cost &amp; high speed. This technology is now used to
initiate projects involving large-scale sequencing of many genomes. The 1000
Genomes project aims to sequence 2500 genomes across 27 world populations, and
has initially completed its Pilot phase. The aim of the project is to discover
&amp; characterize novel variants. These variants enable association studies that
investigate the link between genomic variation &amp; phenotypes, including
disease.

A class of variants, known as "Structural Variants" represent a heterogenous
class of larger variants, such as inversions, duplications, deletions, and
various kinds of insertions.

I use Python to for rapid development of algorithms to process, analyze, and
annotate very large data sets. In particular, I focus on Mobile Elements,
pieces of DNA that copy&amp;paste; across the genome. These elements constitute
roughly half of the genome, whereas protein-coding genes account for roughly
1.5 % of the genome.

I will discuss distributed computing, genomics, and big data within the
context of Python.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Deniz Kural</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/414/pycon-2011--rapid-python-used-on-big-data-to-disc</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/414_rapid-python-used-on-big-data-to-discover-human-genetic-variation.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011RapidPythonUsedOnBigDataToDiscoverHumanGenet382.png"></media:thumbnail></item><item><title>Reverse-engineering Ian Bicking's brain: inside pip and virtualenv</title><link>http://www.pyvideo.org/video/389/pycon-2011--reverse-engineering-ian-bicking--39-s</link><description>&lt;p&gt;Description&lt;/p&gt;
Reverse-engineering Ian Bicking's brain: inside pip and virtualenv

Presented by Carl Meyer

Pip and virtualenv: many use them; not so many understand just how they work
their magic. If you're a pip/virtualenv user but haven't yet dared crack the
lid (or you have, and found it a bit difficult to follow), come along for a
fast-paced guided tour. Knowing these tools will help you make more effective
use of them, and might also turn you into a contributor.

Abstract

Pip and virtualenv are widely used in the Python world, but for the size of
their user base don't receive many code contributions, and many users have
misconceptions about how they actually work.

This talk will cover a bit of advanced use of pip and virtualenv, but mostly
we'll dive into the source code, mapping it out with a high-level view and
diving into the guts of particularly interesting bits. By the end of the talk,
you'll have a good idea exactly how pip and virtualenv do their magic, and
where to go looking in the source for particular behaviors or bug fixes. We'll
walk through the creation of a virtualenv step-by-step, and trace a typical
"pip install -r requirements.txt" and "pip uninstall" through the code paths
they follow.

I'll know the talk was a success when I see the pull requests!

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Carl Meyer</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/389/pycon-2011--reverse-engineering-ian-bicking--39-s</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/389_reverse-engineering-ian-bicking-s-brain-inside-pip-and-virtualenv.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011ReverseengineeringIanBickingsBrainInsidePipAnd764.png"></media:thumbnail></item><item><title>Running Django Apps on Google App Engine</title><link>http://www.pyvideo.org/video/386/running-django-apps-on-google-app-engine</link><description>&lt;p&gt;Description&lt;/p&gt;
Running Django Apps on Google App Engine

Presented by wesley chun

In the past, Django users couldn't run apps unmodified on Google App Engine.
Some tools helped with integration but required you to change your data
models. Django-nonrel removes this requirement letting you run native Django
apps on App Engine with only config changes if you bear in mind its
restrictions like no JOINs. In this talk, we'll discuss Django-nonrel &amp;
porting App Engine apps to Django.

Abstract

Previously, Django users could not get their apps to run unmodified on Google
App Engine, the cloud application-hosting platform. Older tools like "the
Helper" and "the Patch" required a change to the data models as well as
perhaps integrating additional tools into the application source tree. The
creators of the Patch realized how cumbersome this is and created a
replacement for all of these older tools.

Django-nonrel allows users to run pure Django apps on App Engine with only
minor configuration changes. It basically enables Django's ORM to operate on
top of non-relational databases (in addition to preserving its ability to
support standard relational DBs), one of which is Google App Engine's
Datastore. (MongoDB is another.)

What this means that current Django users can now use their existing knowledge
to write apps for App Engine as long as they keep App Engine restrictions in
mind, e.g., no JOINs. Projects written in this manner will work without any
modifications other than changing the configuration settings. On the other
side, App Engine developers now have an alternative to the '"webapp" framework
that comes with its SDK. You can now leverage the power of a full web
framework like Django and still enjoy the flexibility and scalability of App
Engine. In this talk, we'll discuss Django-nonrel, and how to port App Engine
apps from webapp to pure Django to run on App Engine using Django-nonrel.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wesley J. Chun</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/386/running-django-apps-on-google-app-engine</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/386_running-django-apps-on-google-app-engine.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011RunningDjangoAppsOnGoogleAppEngine570.png"></media:thumbnail></item><item><title>Saturday Afternoon Lightning Talks</title><link>http://www.pyvideo.org/video/358/pycon-2011--saturday-afternoon-lightning-talks</link><description>&lt;p&gt;Abstract&lt;/p&gt;
Saturday afternoon lightning talks


&lt;p&gt;Description&lt;/p&gt;
Saturday Afternoon Lightning Talks

  * 00:00 Eric Holscher - Read the Docs ([readthedocs.org](http://readthedocs.org/)) 
  * 05:25 Nate Aune - DjangoZoom ([DjangoZoom](http://djangozoom.com/)) 
  * 09:40 Paul Smith - Update on Japan 
  * 12:40 Phillip von Weitershausen - The English of Programming Languages (JavaScript) 
  * 18:15 Henrique Bastos - Community Bootstrap 
  * 24:00 Barry Warsaw - flufl.i18n library ([https://launchpad.net/flufl.i18n](https://launchpad.net/flufl.i18n)) 
  * 31:20 Aron Griffis - Window Manglement with PyWO ([http://code.google.com/p/pywo/](http://code.google.com/p/pywo/)) 
  * 35:00 Josiah Carlson - Over-Engineering for Dummies 
  * 40:35 Grace Law - Get the job you want 

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/358/pycon-2011--saturday-afternoon-lightning-talks</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/358_saturday-afternoon-lightning-talks.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011SaturdayAfternoonLightningTalks857.png"></media:thumbnail></item><item><title>Saturday Morning Lightning Talks</title><link>http://www.pyvideo.org/video/359/pycon-2011--saturday-morning-lightning-talks</link><description>&lt;p&gt;Abstract&lt;/p&gt;
Saturday morning lightning talks


&lt;p&gt;Description&lt;/p&gt;
Saturday Morning Lightning Talks

  * 00:00 Alfredo Deza - Faster VIM Python Editing ([github.com/alfredodeza/chapa.vim](https://github.com/alfredodeza/chapa.vim)) 
  * 03:40 Dean Hall - Python-on-a-chip ([pythononachip.org](http://pythononachip.org/)) 
  * 07:55 Ned Batchelder - Cog will make you happy ([nedbatchelder.com/code/cog](http://nedbatchelder.com/code/cog)) 
  * 13:55 Brett Cannon - (Some of) your PSF money at work 
  * 21:10 Baiju Muthukaden - GetPython3.net ([getpython3.net](http://getpython3.net/)) 
  * 25:20 Shai Ben-yehuda - Light-weight UI 

[VIDEO HAS ISSUES: slides for Alfredo's and Ned's talks are impossible to
read.]

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/359/pycon-2011--saturday-morning-lightning-talks</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/359_saturday-morning-lightning-talks.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011SaturdayMorningLightningTalks238.png"></media:thumbnail></item><item><title>Scaling Python past 100</title><link>http://www.pyvideo.org/video/397/pycon-2011--scaling-python-past-100</link><description>&lt;p&gt;Description&lt;/p&gt;
Scaling Python past 100

Presented by Mark Ramm

Sourceforge.net has been in the top 100 sites on the internet, and we
discovered that python was easily able to scale up to handle that traffic. In
fact Python is now the core language for all new features, and is taking over
all of sourceforge.net.

Abstract

The path from legacy PHP to modern python tools has been long an bumpy, and
this is the story of how we took Python from a single prototype site, to the
core technology driving SourceForge.net. I will discuss the mistakes we made
along the way, the benefits that sold python, and the real secret behind our
python transformation.

A few highlights include:

  * How we abused libraries for fun and profit 
  * How a major mistake made us look good 
  * How the python community worked for us 
  * How we couldn't have done it without Django AND TurboGears 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Mark Ramm</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/397/pycon-2011--scaling-python-past-100</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/397_scaling-python-past-100.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011ScalingPythonPast100645-312.jpg"></media:thumbnail></item><item><title>Serious Business: Python is not just for Engineering</title><link>http://www.pyvideo.org/video/444/pycon-2011--serious-business--python-is-not-just-</link><description>&lt;p&gt;Description&lt;/p&gt;
Serious Business: Python is not just for Engineering

Presented by Zach Steindler

Building a great business is quite different from building a great product,
but by measuring Key Performance Indicators (things like cash flow, if users
keep coming back, etc.) you can make sure your business is on the right track.
In this talk I'll cover common KPI in the tech business and show you how we
automate collecting and presenting KPI at Olark.

Abstract

As a hacker-turned-founder, you quickly realize there's more to building a
great business than just building a great product. The easiest way to know
your business is on the right track is to measure Key Performance Indicators
(KPIs): things like cash flow, what parts of the product is used the most, if
your users keep coming back, if users are experiencing problems... and many,
many others. How are you supposed to keep track of it all without getting lost
in a sea of noise?

With Python, of course! In this talk I'll cover the most common KPIs
technology businesses track and show you how we used Python at Olark to
automatically collect and present KPIs to the team. This has made it much
easier to quickly answer business questions and help us know we're on the
right track.

So if you're a Python hacker who would like to learn more about how to
engineer a business, or if you're a business person who's just starting to
learn Python, come learn how Python isn't just for engineering.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zach Steindler</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/444/pycon-2011--serious-business--python-is-not-just-</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/444_serious-business-python-is-not-just-for-engineering.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011SeriousBusinessPythonIsNotJustForEngineering609.png"></media:thumbnail></item><item><title>SOLVCON: A New Python-Based Software Framework for Massively Parallelized Numerical Simulations</title><link>http://www.pyvideo.org/video/382/pycon-2011--solvcon--a-new-python-based-software-</link><description>&lt;p&gt;Description&lt;/p&gt;
SOLVCON: A New Python-Based Software Framework for Massively Parallelized
Numerical Simulations

Presented by Yung-Yu Chen

SOLVCON is the first Python-based software framework for high-resolution
simulations of multi-physics conservation laws. More than ninety percents of
the codes are done in Python. Performance hot-spots are optimized by C and
glued by ctypes library. SOLVCON is high-performance in nature and has been
able to utilize 512 4-core nodes at Ohio Supercomputer Center.

Abstract

In this decade, performance improvements of scientific computing will mainly
come from major changes in the computing hardware. A well-organized software
structure is imperative to accommodate such changes. Based on Python, SOLVCON
([http://solvcon.net/](http://solvcon.net/)) is designed as a software
framework to develop conservation-law solvers by segregating solving kernels
from various supportive functionalities. Being the governing equations for the
physical world, conservation laws are applied everywhere in science and
engineering. Although it is well known that the numerical algorithms and
physical models form the kernel of any conservation-law solver, few if not
none code can cleanly separate those core components from supportive
functionalities. The lack of organization has hindered the development of
legacy codes. To address the issues, the supportive functionalities are
internalized in the framework of SOLVCON. Aided by the framework, both multi-
physics and hybrid parallelism can be implemented in an organized way. To
date, SOLVCON has utilized up to 512 4-core nodes at Ohio Supercomputer Center
for high-resolution simulations of computational fluid dynamics (CFD). SOLVCON
targets to concurrently utilize thousands of computer nodes for high-
resolution simulations using over one billion mesh points.

One of the major purposes of SOLVCON is to resolve the complicated programming
efforts for GPU clusters. Supercomputing is undergoing the third revolution by
the emerging GPU computing. To date, the fastest supercomputer in the Top 500
list, Tianhe-1A, is a GPU cluster. GPU computing promises numerical analysts
to reduce the time for the high-resolution simulations from months to days. In
order to use GPU computing to accelerate such large-scale problems, GPU nodes
must be networked together to form a GPU cluster. As such, shared-memory and
distributed-memory parallelization must be simultaneously utilized to achieve
the so-called hybrid parallelism. Parallel computing is difficult, and hybrid
parallel computing is more difficult. By using Python to develop the
fundamental software structure, GPU or multi-threaded programming for shared-
memory parallelization are locked in solving kernels. Complex message-passing
is implemented in SOLVCON and isolated from solving-kernel developers. Highly
optimized C and GPU codes are glued into SOLVCON without loss of performance
by using the ctypes package. Othere important features of SOLVCON include:

  * Pluggable multi-physics.
  * Built-in [CESE](http://www.grc.nasa.gov/WWW/microbus/) solvers.
  * Unstructured mesh consisting of mixed elements.
  * Interface to Message-Passing Interface (MPI) libraries.
  * Socket communication layer: working without MPI installed.
  * Automatic distributed-memory parallelization by domain decomposition.
  * Parallel I/O.
  * In situ visualization by [VTK](http://vtk.org) library.
  * Standalone writers to VTK legacy and XML file formats.
  * Integration to supercomputer (cluster) batch systems.

SOLVCON has been applied to computation fluid dynamics and computational
mechanics. More physical solvers are being developed for various propagating
wave problems, e.g., electromagnetic waves. By using Python as the foundation
in SOLVCON, performance and extensibility are well balanced, and computational
research is being done in the most productive way. In this talk, the author of
SOLVCON will make an introduction to the software framework by including the
following topics:

  1. Simulations of conservation laws and hybrid parallelism for supercomputing.
  2. Issues in legacy codes and challenges to code for emerging supercomputer hardware.
  3. Using SOLVCON in the simple way by pre-defined modules.
  4. Fixed parts in SOLVCON. 
    1. Distributed computing.
    2. Multi-thread utilities.
  5. Customizable parts in SOLVCON. 
    1. Pluggable multi-physics and GPGPU computing.
    2. Supercomputer batch system and bootstrapping.
    3. In situ visualization.
  6. Conclusion.

The talk will take 30 minutes.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Yung-Yu Chen</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/382/pycon-2011--solvcon--a-new-python-based-software-</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/382_solvcon-a-new-python-based-software-framework-for-massively-parallelized-numerical-simulations.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011SOLVCONANewPythonBasedSoftwareFrameworkForMass564.png"></media:thumbnail></item><item><title>State of Pylons/TurboGears 2/repoze.bfg</title><link>http://www.pyvideo.org/video/446/pycon-2011--state-of-pylons-turbogears-2-repoze-b</link><description>&lt;p&gt;Description&lt;/p&gt;
State of Pylons/TurboGears 2/repoze.bfg

Presented by Chris McDonough, Ben Bangert, and Mark Ramm

A three-for-one talk by the main developers of three popular Python web
frameworks! We'll (very) briefly cover the state of each of our individual
frameworks and communities, and then we'll describe the results of our efforts
to work together and share code.

Abstract

Pylons is a popular, lightweight Python web framework.

TurboGears 2 is a full-stack framework built atop Pylons.

repoze.bfg is a moderately popular, lightweight Python web framework.

The main developers and community leaders of these frameworks have been
working together and sharing as much as possible over the course of roughly
the last year. We'll very briefly describe to the audience the states of our
individual efforts, then we'll discuss how we intend to move forward and share
more code and effort in the year to come. The talk will be more socially-
oriented than technical.

It's unusual for open source code and communities to bridge minor perceived
differences in scope and style and to start sharing code and ideas openly. If
you're a user of any of these frameworks, you'll want to be present for this
talk.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Ben Bangert,Chris McDonough,Mark Ramm</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/446/pycon-2011--state-of-pylons-turbogears-2-repoze-b</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/446_state-of-pylons-turbogears-2-repoze-bfg.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011StateOfPylonsTurboGears2repozebfg818.png"></media:thumbnail></item><item><title>Statistical machine learning for text classification with scikit-learn</title><link>http://www.pyvideo.org/video/417/pycon-2011--statistical-machine-learning-for-text</link><description>&lt;p&gt;Description&lt;/p&gt;
Statistical machine learning for text classification with scikit-learn

Presented by Olivier Grisel

The goal of this talk is to give a state-of-the-art overview of machine
learning algorithms applied to text classification tasks ranging from language
and topic detection in tweets and web pages to sentiment analysis in consumer
products reviews.

Abstract

Unstructured or semi-structured text data is ubiquitous thanks to the read-
write nature of the web. However human authors are often lazy and don't fill-
in structured metadata forms in web applications. It is however possible to
automate some structured knowledge extraction with simple and scalable
statistical learning tools implemented in python. For instance:

  * guessing the language and topic of tweets and web pages 
  * analyze the sentiment (positive or negative) in consumer products reviews in blogs or customer emails 

This talk will introduce the main operational steps of supervised learning:

  * extracting the relevant features from text documents 
  * selecting the right machine learning algorithm to train a model for the task at hand 
  * using the trained model on previously unseen documents 
  * evaluating the predictive accuracy of the trained model 

We will also demonstrate the results obtained for above tasks using the
[scikit-learn](http://scikit-learn.sourceforge.net/) package and compare it to
other implementations such as [nltk](http://nltk.org/) and the [Google
Prediction API](http://code.google.com/apis/predict/).

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Olivier Grisel</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/417/pycon-2011--statistical-machine-learning-for-text</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/417_statistical-machine-learning-for-text-classification-with-scikit-learn.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011StatisticalMachineLearningForTextClassification447.png"></media:thumbnail></item><item><title>Status of Unicode in Python 3</title><link>http://www.pyvideo.org/video/364/pycon-2011--status-of-unicode-in-python-3</link><description>&lt;p&gt;Abstract&lt;/p&gt;
Introduced in Python 2.0, unicode became the default string type in Python
3.0. It took 8 years to switch to unicode, and since Python 3.0, a lot of bugs
has been fixed. The switch to unicode opened many questions. Should Python
support both bytes and characters for filenames? What to do with undecodable
bytes? etc.


&lt;p&gt;Description&lt;/p&gt;
The talk will focus on the recent issues fixed in Python 3.1 and 3.2:

  * Use the PEP 383 (error handler to store undecodable bytes) everywhere 
  * Encoding of the command line arguments: utf-8 on Mac OS X, locale encoding on UNIX/BSD, unicode on Windows 
  * Environment variables: creation of os.environb 
  * Filenames: huge work to support the PEP 383 everywhere, creation of os.fsencode() and os.fsdecode() 
  * Python source code encoding: use tokenize.detect_encoding() instead of the locale encoding 
  * some library examples: email, ftp, ... 
  * etc. 

The talk will present not only the changes in Python, but also in the C API.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Victor Stinner</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/364/pycon-2011--status-of-unicode-in-python-3</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/364_status-of-unicode-in-python-3.ogv" length="173547130" type="video/ogg"></enclosure><media:group><media:content url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/364_status-of-unicode-in-python-3.ogv" fileSize="173547130" mime_type="video/ogg"></media:content><media:content url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/364_status-of-unicode-in-python-3.m4v" mime_type="video/mp4"></media:content></media:group><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011StatusOfUnicodeInPython3393.png"></media:thumbnail></item><item><title>Sunday Afternoon Lightning Talks</title><link>http://www.pyvideo.org/video/357/pycon-2011--sunday-afternoon-lightning-talks</link><description>&lt;p&gt;Description&lt;/p&gt;
Sunday Afternoon Lightning Talks

  * 00:40 Paul Smith - Japan 
  * 03:10 Zed Shaw - Being Passionate 
  * 05:40 Pete Fein - Twiggy: A Pythonic Logger 
  * 11:15 Remy DeCausemaker - FOSS@RIT: 
  * 16:15 Evgeny Fadeev - Askbot ([askbot.org](http://askbot.org/)) 
  * 21:05 Carl Karsen - Video subtitles ([universalsubtitles.org](http://universalsubtitles.org/), [python.mirocommunity.org](http://python.mirocommunity.org/)) 
  * 25:45 Larry Hastings - Minuteman ([www.larryhastings.com/minuteman](http://www.larryhastings.com/minuteman/)) 
  * 31:50 Mike Pirnat - Win at parenting with Python ([howoldismykid.com](http://howoldismykid.com/)) 
  * 36:15 Barry Warsaw - flufl.enum ([launchpad.net/flufl.enum](https://launchpad.net/flufl.enum)) 
  * 40:45 Jonathan Hartley - Make a game for PyWeek ([www.pyweek.org](http://www.pyweek.org/)) 
  * 45:30 Gregory P. Smith - Protobufs for data storage and transport ([code.google.com/p/protobuf](http://code.google.com/p/protobuf/)) 
  * 50:45 Dan Bentley - 2to3 + MOE 
  * 56:15 Dino Viehland - Python tools for Visual Studio 
  * 1:01:00 Moshe Zadka - Bayes' Theorem for Programmers 
  * 1:04:50 Brandon Rhodes - Adventure in Python 
  * 1:10:20 Whit Morriss - Sharing is caring, FOSS and Python at SurveyMonkey 
  * 1:15:25 Kumar McMillan - Fudging it with Mock Objects ([farmdev.com/projects/fudge/](http://farmdev.com/projects/fudge/)) 

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/357/pycon-2011--sunday-afternoon-lightning-talks</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/357_sunday-afternoon-lightning-talks.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011SundayAfternoonLightningTalks799-486.jpg"></media:thumbnail></item><item><title>Supercomputer and Cluster Application Performance Analysis using Python</title><link>http://www.pyvideo.org/video/450/pycon-2011--supercomputer-and-cluster-application</link><description>&lt;p&gt;Description&lt;/p&gt;
PyCon 2011: Supercomputer and Cluster Application Performance Analysis using
Python

Presented by Daniel W. Barnette, PhD

Sandia National Labs analyzes high-performance computing environments to
optimize application performance, analyze system architectures, and provide
design guidance for future systems. We discuss 1) generating performance data
across multiple systems using mini-applications, and 2) using our open source
Python tools Pylot/Co-Pylot to store and analyze data using a MySQL database
server.

Abstract

Sandia National Laboratories analyzes large-scale, state-of-the-art high
performance computing environments for the Department of Energy (DOE),
Department of Defense (DoD), and other government agencies. Execution
efficiency is vital when dealing with datasets that require billions of
elements or when running simulations that take millions of core-hours to
complete.

One approach to investigating execution efficiency is to instrument our large-
scale applications and platforms to generate timings and other performance
data. Although effective in mature computing environments, working directly
with large-scale applications is cumbersome, time consuming, and even
impossible in the early stages of computer system analysis and design.
Furthermore, the software and data sets of these applications may be
restricted, limiting our abilities to collaborate.

In order to enhance our analysis capabilities far upstream from when large-
scale applications can be used and when working with external collaborators,
we have developed a collection of mini-applications that capture the essence
of our much larger scientific codes, are readily applicable to both large and
small systems, and whose run-time information can accurately reveal problems
associated with execution efficiency.

Generating the data is only half the problem, though. We need the ability to
capture platform-relevant mini-app performance data at the convenience of the
testers when and where they generate the data. We also need the ability to
search through, filter, and visualize the resulting performance measurement
datasets in detail to identify and understand trends and patterns.

Sandia National Laboratories has developed a performance analysis suite
primarily consisting of two tools written in Python, Pylot and Co-Pylot. Co-
Pylot is a relatively simple interface that enables easy batch transfer of
performance data to a remote MySQL database server for persistent storage.

Once stored, the performance data is extracted, organized, filtered, and
analyzed using Pylot, a more functionally complex interface. Pylot is used to
present user-selected MySQL database fields in a variety of views including
statistical data, bar and pie charts, Cartesian or log-log or semi-log plots,
reference curves for comparisons, and Kiviat diagrams (also called radar
charts) for multivariate datasets.

A built-in storage buffer provides the ability to store, compare, and analyze
data from multiple databases. This capability is critical for studying
performance variations of a code running on a particular architecture,
comparing application performance across architectures, or comparing multiple
applications on one or more architectures. Values in up to four database
fields at a time can be mathematically combined to generate a new temporary
field to provide complete generality while accessing a database. Further,
Pylot provides the ability to easily move MySQL databases and tables between
computers, including the analyst’s laptop. This coherency of databases across
multiple analysis platforms can be used, for example, to avoid network latency
issues associated with accessing remote servers. It also serves as a
distributed backup system.

An outline of this presentation follows:

  1. Applications at Sandia National Laboratories (6 mins) 
    * Simulation size and runtime of typical large Sandia applications 
    * Difficulties of using large-scale applications in early computer system design and analysis 
    * Mantevo mini-apps – small, self-contained programs that embody essential performance characteristics of key applications. 
  2. Gathering data (4 mins) 
    * What information Mantevo mini-apps provide 
    * Co-Pylot – getting your data into a remote database 
  3. Supercomputer and Cluster application analysis (10 mins) 
    * Pylot – demo of accessing and graphing MySQL data as a method for analyzing performance 
    * Diagnosing performance issues 
    * Comparing different systems and different runs 
  4. Future Extensions of Pylot (5 mins) 
    * Capturing compile-time and execution info 
    * Efforts to move parts of Pylot to the web 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daniel W. Barnette</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/450/pycon-2011--supercomputer-and-cluster-application</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/450_supercomputer-and-cluster-application-performance-analysis-using-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011SupercomputerAndClusterApplicationPerformanceAna648.png"></media:thumbnail></item><item><title>Supporting All Versions of Python All The Time With Tox</title><link>http://www.pyvideo.org/video/435/pycon-2011--supporting-all-versions-of-python-all</link><description>&lt;p&gt;Description&lt;/p&gt;
Supporting All Versions of Python All The Time With Tox

Presented by Kumar McMillan

This talk explains the modern techniques that every module maintainer needs to
know in order to support all major versions of Python. You probably already
have a massive test suite using a tool like nosetests, py.test, unittest, or a
custom runner. Using the tox command line tool, you'll see how to run your
tests in Python 2.x, 3.x, Jython, and whatever else in parallel.

Abstract

tox is a new tool that lets you set up isolated virtual environments to test
your module's deployment and compatibility with all major versions of Python.
It's easy to install and is flexible enough that it probably already supports
your existing test suite. With one simple command you can execute your test
suite in each version of Python, you can build its documentation with Sphinx,
and get a nice printout of the results. It has also been designed from the
ground up to integrate into continuous integration (CI) tools like Hudson.

Using practical examples, this talk will show you how to toxify your existing
test suite and trick it out with the tox.ini config file. You'll also see how
to leverage Hudson's matrix build so that each code checkin will run tests in
all versions of Python and report detailed failures.

Your app supports Python 3, right? No? Tox is the best way to develop in
parallel with 2.x and 3.x. We'll go over how to set up tox for that.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Kumar McMillan</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/435/pycon-2011--supporting-all-versions-of-python-all</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/435_supporting-all-versions-of-python-all-the-time-with-tox.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011SupportingAllVersionsOfPythonAllTheTimeWithT333.png"></media:thumbnail></item><item><title>Swarming the Web: Evolving the Perfect Config File</title><link>http://www.pyvideo.org/video/405/pycon-2011--swarming-the-web--evolving-the-perfec</link><description>&lt;p&gt;Description&lt;/p&gt;
Swarming the Web: Evolving the Perfect Config File

Presented by Kurt Grandis

Deployed web applications are typically run on top of stacks of highly
configurable middleware. The number of tunable parameters and their impact are
rarely fully explored. Using SciPy and a set of common Python-based web tools
this session will present a new method of automatically tuning a typical LAMP
stack for optimal performance.

Abstract

Deployed web applications typically run on top of stacks of configurable
technology (e.g. web servers, interface modules, software load balancers,
databases). Each of these components often has dozens of tuneable parameters.
How many times are those values typically tweaked before a final set of tuned
parameters are settled on? What criteria are typically used to determine the
optimal set?

This session presents a new method of automatically tuning a common LAMP stack
for optimal performance. We explore a solution using some common Python-based
automated deployment and load testing tools and dive into scientific computing
with SciPy.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Kurt Grandis</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/405/pycon-2011--swarming-the-web--evolving-the-perfec</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/405_swarming-the-web-evolving-the-perfect-config-file.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011SwarmingTheWebEvolvingThePerfectConfigFile838.png"></media:thumbnail></item><item><title>Ten Years of Twisted</title><link>http://www.pyvideo.org/video/410/pycon-2011--ten-years-of-twisted</link><description>&lt;p&gt;Description&lt;/p&gt;
Ten Years of Twisted

Glyph Lefkowitz

The Twisted event-driven networking engine is well-known in the Python
community. However, only a few of its features are widely understood. This
talk will be a brief conceptual introduction to Twisted, followed by a survey
of its features, their status, and how development has been proceeding over
the years, with a special focus on the last two years of sponsored
development.

Abstract

This talk will begin with a brief introduction to Twisted architectural
concepts; a description of the event loop, connections, and timers. It will
then segue into the many different features that Twisted offers, including
command-line tools for running an out-of-the-box zero-configuration HTTP
server, DNS server, IRC server, and SMTP server. This will also present the
relative maturity and stability of each of these areas of the code, with a
special emphasis on what level of expertise a developer should have before
attempting to use them. Finally, I will describe some of the features that
have been added to Twisted along the way, including some new and exciting
developments that have been happening recently.

</description><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/410/pycon-2011--ten-years-of-twisted</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/410_ten-years-of-twisted.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011TenYearsOfTwisted381.png"></media:thumbnail></item><item><title>Testing the Mobile (and Desktop) Web with Selenium 2.0 - Better, Faster, and more Pythonicly</title><link>http://www.pyvideo.org/video/373/pycon-2011--testing-the-mobile--and-desktop--web-</link><description>&lt;p&gt;Description&lt;/p&gt;
Testing the Mobile (and Desktop) Web with Selenium 2.0 - Better, Faster, and
more Pythonicly

Presented by Jason Huggins

Selenium is a popular web application testing tool for acceptance testing
dynamic web applications. Selenium 2.0 has a different architecture that makes
it leaner, meaner, and more pythonic -- for testing desktop *and* mobile web
(iPhone/Android) apps. This talk will go into detail on how Selenium 2 works.
If you like testing and Python, you'll enjoy what's cooking in Selenium 2.

Abstract

Selenium was originally created by Jason Huggins and his team at ThoughtWorks
in 2004 as a tool for cross-browser acceptance testing of dynamic web apps --
apps that use JavaScript heavily on the client. Over the years, the Selenium
tool family has expanded to include a Firefox record and playback tool
(Selenium IDE), a Remote Control server that allows API access from any major
programming language, and a Grid server that allows tests to run in parallel
across many machines.

Despite it's widespread industry adoption, the Selenium project is far from
done. Selenium's goal is to drive any browser the same way an end user would
(e.g. opening pages, clicking buttons, entering text, etc.) with any
programming language on any OS platform. It's an ambitious goal, and with a
steady stream of new browsers (Chrome), new platforms (Android, iPhone), and
new HTML5 technologies (video, canvas, offline storage) to support, just
keeping up is an arduous task.

Astute observers will note, though, the bulk of Selenium's automation engine
is implemented in JavaScript, which is confined by the browser's security
sandbox in which it executes JavaScript code. That security sandbox ultimately
is at odds with Selenium's goal to drive the browser just as a user would. A
user has no problem interacting with security alerts for untrusted
certificates, or file upload dialog boxes, but Selenium can't deal with these
kinds of things easily without extra effort.

Enter WebDriver. There's a lot in common between the Selenium and WebDriver
projects. They're both tools for automated testing of web applications, and
both aspire to offer browser test automation from any language on any
platform. However, they do their thing in radically different ways. Selenium
uses the strategy that JavaScript is the one common tool available for
automating all browsers, even though its capabilities can be highly
constrained. Meanwhile, WebDriver leverages the strategy that acknowledges
different automation strategies work best for different browsers. COM works
best for IE on Windows, Apple Events for Safari on OS X. And Firefox, well,
the best way to natively automate Firefox is to turn it into a telnet server.
(But that's a whole other PyCon talk entirely!) WebDriver aims to natively
drive each browser the best way possible for maximum capability, then hiding
those differences between lower level C and C++ APIs, and finally exposing the
functionality through the appropriate C/C++ mechanism for each target
language, such as using ctypes for Python. With WebDriver's technical
approach, anything a user can do is now possible in test automation code.

This talk will go into detail explaining how Selenium and WebDriver (aka
Selenium 2) work, comparing the strengths and weaknesses of each tool's
approach to browser automation. The talk will then explain what Selenium 2.0
looks like and how to use it.

Talk outline:

  * Description of problem space 
    * More browsers 
    * More frequent browser releases 
    * HTML 5 - video, canvas, offline storage 
    * The web in more places - Mobile, Chrome OS 
  * Description of Selenium 
  * Strengths of Selenium 
  * Description of challenges for Selenium 1 
    * Javascript security sandbox 
    * Same origin policy / cross-site scripting 
    * OS-level popups 
    * Speed / stability 
    * Java as the cross-language integration point (aka Not Very Pythonic, eh?) 
  * Description of Selenium 2 (aka WebDriver) 
  * Strengths of Selenium 2 
  * How Selenium 2 is more pythonic 
    * (Lots and lots of example code goes here.) 
    * Spoiler Alert: No Java server required! 
  * How to test Android apps 
  * How to test iPhone apps 
  * Selenium development roadmap 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jason Huggins</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/373/pycon-2011--testing-the-mobile--and-desktop--web-</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/373_testing-the-mobile-and-desktop-web-with-selenium-2-0-better-faster-and-more-pythonicly.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011TestingTheMobileAndDesktopWebWithSelenium20524.png"></media:thumbnail></item><item><title>Testing with mock</title><link>http://www.pyvideo.org/video/392/pycon-2011--testing-with-mock</link><description>&lt;p&gt;Description&lt;/p&gt;
Testing with mock

Presented by Michael Foord

mock is a Python testing library. It has the goal of making mocking in tests
brain dead simple! mock provides the Mock class and the patch decorator for
safely patching out the objects you are mocking in your tests. This talk will
cover standard mocking patterns. We'll also look at some of the newer features
in the latest release, including support for mocking magic methods.

Abstract

mock provides a core Mock class that removes the need to create a host of
trivial stubs throughout your test suite. After performing an action, you can
make assertions about which methods / attributes were used and arguments they
were called with. You can also specify return values and set specific
attributes in the normal way.

  * [http://www.voidspace.org.uk/python/mock/](http://www.voidspace.org.uk/python/mock/)
  * [http://pypi.python.org/pypi/mock/](http://pypi.python.org/pypi/mock/)

The mock module also provides a patch() decorator that handles safely patching
out the things you are mocking during your test.

We'll cover standard mocking patterns, and how mock makes them easy. We'll
also be looking at some of the newer features in the latest release, including
the magic method support that can be used (for example) for mocking out
objects used as context managers.

mock is designed for "unit test style" testing, but is used with Python
testing libraries like nose and py.test.

There will be some emphasis on how *not* to use mocking in testing, and why
'over mocking' is bad (and makes for brittle tests).

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael Foord</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/392/pycon-2011--testing-with-mock</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/392_testing-with-mock.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011TestingWithMock498.png"></media:thumbnail></item><item><title>The Data Structures of Python</title><link>http://www.pyvideo.org/video/420/pycon-2011--the-data-structures-of-python</link><description>&lt;p&gt;Description&lt;/p&gt;
The Data Structures of Python

Presented by Alex Gaynor

Any Python programmer knows about the major builtin data strcutres, lists,
dicts, tuples, but do you always remember when you're supposed to use them? Do
you know about all the cool data structures hidden in the standard library?
This talk will be a review of the characteristics of the different data
structures, and a tour of idiomatic ways to use some of the structures in the
standard library.

Abstract

First, as a note this talk borders between survey and discuss in depth. For
each data structure I want to cover their implementation, performance
characteristics, and idiomatic usage (e.g. tuples vs. lists), a lot of them
have similar implementations so idiomatic usage will dominate for some of
them.

  * The builtins (10 minutes) 
    * lists 
      * Ordered collections of any type of objects 
      * Mutable 
      * Implemented as an array of pointers 
    * tuples 
      * Ordered collections of any type of objects 
      * Immutable* 
      * Implemented as a fixed-length array of pointers 
    * dicts 
      * Unordered mapping of hashable objects to any objects 
      * Mutable 
        * Why no immutable variant
      * Implemented as an open-addressed hash table. 
    * sets 
      * Unordered collection of hashable objects 
      * Mutable 
        * frozenset
      * Implemented as an open-addressed hash table. 
  * The Standard Library (10 minutes) 
    * OrderedDict 
      * Ordered mapping of hashable objects to any objects 
      * Mutable 
      * Implemented as a dict with a doubly-linked list running through it. 
    * deque 
      * Ordered collection of any type of objects 
      * Mutable 
      * Implemented as an unrolled, doubly-linked list 
    * namedtuple 
      * Ordered collection of any type of objects, *also* addressable by name. 
      * Immutable 
      * Implemented as a tuple with extra properties 
    * array 
      * Like a list... but limited to "primitve" types. 
  * Performance characteristics. 
  * Writing your own (5 minutes) 
    * Abstract Base Classes 
      * Duck typing 
        * Why would you want to use them!
      * What's available. 
    * OrderedSet 
      * An ordered collection of hashable objects 
      * Mutable 
      * Implemented as a set with a doubly-linked list running through it. 
  * Questions (5 minutes) 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Gaynor</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/420/pycon-2011--the-data-structures-of-python</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/420_the-data-structures-of-python.ogv" length="161075055" type="video/ogg"></enclosure><media:group><media:content url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/420_the-data-structures-of-python.ogv" fileSize="161075055" mime_type="video/ogg"></media:content><media:content url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/420_the-data-structures-of-python.m4v" mime_type="video/mp4"></media:content></media:group><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011TheDataStructuresOfPython246.png"></media:thumbnail></item><item><title>The Development of Python and You</title><link>http://www.pyvideo.org/video/432/pycon-2011--the-development-of-python-and-you</link><description>&lt;p&gt;Description&lt;/p&gt;
The Development of Python and You

Presented by Brian Curtin

Have an inside look at what it takes to work on CPython, from getting setup
with the source and navigating the bug tracker, to the best practices for
having your work accepted. We'll find, categorize, and fix an issue in Python
to get you started. This talk is ideal for those who are new to open source
projects or are interested in the Python development process.

Abstract

People from all backgrounds, users of all platforms, and developers of all
levels are necessary in the development of Python. From writing code to
documentation, it takes all kinds of people to make an impact. If you've used
Python, we need you, and what better place to get involved than at PyCon?

2010 saw a rise in the number of contributors to CPython, and the PSF stepped
in to support the efforts of those wanting to get involved. Are you up for the
challenge? This talk dives right into what it takes to get involved, covering
the who, what, where, when, and why of Python development, going through the
whole process live.

After the conference is over, stick around with the CPython crew and hack
away!

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Brian Curtin</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/432/pycon-2011--the-development-of-python-and-you</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/432_the-development-of-python-and-you.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011TheDevelopmentOfPythonAndYou317.png"></media:thumbnail></item><item><title>The Pyramid FAQ</title><link>http://www.pyvideo.org/video/387/pycon-2011--the-pyramid-faq</link><description>&lt;p&gt;Description&lt;/p&gt;
The Pyramid FAQ

Presented by Carlos de la Guardia

The #pylons IRC channel is the most common way of giving support to users of
the Pyramid framework. In this talk we take away some of the most often
discussed topics in the channel and give detailed answers to them.

Abstract

Every development project has a few questions and doubts that seem to come up
on its support channels every now and then. The Pyramid framework is no
exception.

In this talk, we introduce Pyramid related FAQs using the chat logs and
proceed to discuss them in detail. Showing the logs allows us to give the talk
a lighter side and makes for an introduction to each topic based on real user
questions.

Topics covered here include:

  * Configuration objects. 
  * Object traversal versus URL dispatch. 
  * Context and views. 
  * Authentication and authorization. 
  * How much 'Zope stuff' is there in Pyramid and can we take it away? 
  * Examples of how Pyramid enables the Pylons philosophy of integrating best of breed or preferred components. 
  * The future of Pyramid and Pylons. 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Carlos de la Guardia</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/387/pycon-2011--the-pyramid-faq</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/387_the-pyramid-faq.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011ThePyramidFAQ994-532.jpg"></media:thumbnail></item><item><title>The Python That Wasn't</title><link>http://www.pyvideo.org/video/406/pycon-2011--the-python-that-wasn--39-t</link><description>&lt;p&gt;Description&lt;/p&gt;
The Python That Wasn't

Presented by Larry Hastings

One reason for Python's success is its restraint in adding new language
features. Only the most essential changes make it--and for every change that
gets accepted, many more are rejected. Come learn about proposed changes to
the Python language that failed--what, how, and why.

Abstract

  * Quick overview of the process 
    * First ten years: send GvR a patch 
    * The modern approach: python-ideas, write a PEP, produce a reference implementation 
  * Discuss the "prickly" Python community 
    * This is a good thing! Only the best ideas survive the python-dev gauntlet! 
    * They do this not because they're mean, but because they care so much. 
    * We must have eternal vigilance to prevent unnecessary changes! 
  * A survey of some changes that didn't make it 
    * The switch/case statement (PEP 3103) 
    * The "freeze protocol" (PEP 351) 
    * The "dynamic attribute access" proposal from python-dev, 2007/02 
    * Many more possibilities await in the rejected PEPs! 
  * My message to the audience 
    * Start with a post to python-ideas, please! 
    * Don't be surprised if you get a negative reaction 
    * Don't let your fear of a negative reaction stop you from trying, necessarily 
    * Do your homework, and be your own worst critic 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Larry Hastings</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/406/pycon-2011--the-python-that-wasn--39-t</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/406_the-python-that-wasn-t.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011ThePythonThatWasnt367.png"></media:thumbnail></item><item><title>Through the Side Channel: Timing and Implementation Attacks in Python</title><link>http://www.pyvideo.org/video/423/pycon-2011--through-the-side-channel--timing-and-</link><description>&lt;p&gt;Description&lt;/p&gt;
Through the Side Channel: Timing and Implementation Attacks in Python

Presented by Geremy Condra

Python's dynamic nature, large standard library, and concern for beauty over
performance make it an elegant and uniquely easy to use language, but they
also cause some unique problems. In this talk we'll explore how features
ranging from dictionaries to duck typing can become security risks,
demonstrate those attacks on real Python projects, and examine how you can
protect yourself and your code.

Abstract

Over the last decade, an increasing body of evidence has accumulated
indicating that even when a system is hardened enough to provide strong
guarantees about its high-level behavior, implementation details and
especially performance properties can still provide attackers with an easy way
in. For Python, this is especially problematic: its generally high-level view
and the emphasis placed on flexibility often mean that it can be difficult to
stop attackers from gaining a foothold, while its comparatively low execution
speed increases the efficacy of wide variety of implementation and timing
attacks.

To help Pythonistas understand and cope with these problems, we've divided
this talk into two parts: in the first, we demonstrate the attacks against a
series of widely-deployed Python projects with the goal of both improving
awareness about the issue and demonstrating common weaknesses to be avoided.
The second demonstrates effective countermeasures and alternative
constructions with the goal of improving defenders' odds of spotting and
correcting these flaws in their own code.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Geremy Condra</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/423/pycon-2011--through-the-side-channel--timing-and-</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/423_through-the-side-channel-timing-and-implementation-attacks-in-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011ThroughTheSideChannelTimingAndImplementationAt601.png"></media:thumbnail></item><item><title>TUF: Secure Software Updates in Python</title><link>http://www.pyvideo.org/video/412/pycon-2011--tuf--secure-software-updates-in-pytho</link><description>&lt;p&gt;Description&lt;/p&gt;
TUF: Secure Software Updates in Python

Presented by Geremy Condra

From an attacker's point of view there are few entry points with as much to
offer as a vulnerable software updater, yet history tells us that such
vulnerabilities are common. In this talk we'll demonstrate a number of
attacks, explain how common approaches fail to defend against them, and
demonstrate a pure Python library (TUF) that provides both robust protection
and extreme ease of use.

Abstract

Vulnerabilities in software update systems expose users to huge range of
potential security risks, including:

  * Freeze attacks, 
  * Mix-and-match attacks, 
  * Rollback attacks, and 
  * Endless data attacks 

In the first part of this talk, we'll demonstrate each of these against real-
world software updaters and explain how commonly used countermeasures fail in
application. We'll then move on to the second part of the talk, demonstrating
TUF, its internals, and the mechanisms it uses to additionally defend against
key compromise. Finally, we'll demonstrate how easy it is to integrate TUF
into your application and its lifecycle.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Geremy Condra</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/412/pycon-2011--tuf--secure-software-updates-in-pytho</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/412_tuf-secure-software-updates-in-python.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011TUFSecureSoftwareUpdatesInPython643-944.jpg"></media:thumbnail></item><item><title>Units Need Testing Too</title><link>http://www.pyvideo.org/video/422/pycon-2011--units-need-testing-too</link><description>&lt;p&gt;Description&lt;/p&gt;
Units Need Testing Too

Presented by Gary Bernhardt

Python's long history of testing has focused primarily on integration- and
system-level tests: slow-running tests executing lots of code. These are a
great start, but many of them can be transformed into unit-level tests. True
unit tests are orders of magnitude faster (about 1ms each), providing quicker
feedback and better failure localization. We'll look at why and how to write
them.

Abstract

Python has a wonderful legacy in testing: PyUnit has been in the standard
library since March, 2001, and it was already a year old by then. We adopted
browser driving quickly, and we do it at huge scale with great test
parallelization infrastructure.

Big tests aren't everything, though. In the Python world, true unit tests are
somewhat rare, and even most tests written with the unittest library are
integration tests. These tests are slow to execute and don't localize failure
as well as smaller, focused tests. They leave us with two options: either run
them rarely, sacrificing feedback, or run them often, sacrificing speed.

Writing true unit tests removes that particular trade-off. When your tests
execute in a millisecond each, you can afford to run a thousand of them every
time you save a source file. This talk will discuss what unit tests really
are, why they matter, and how to write them in Python.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Gary Bernhardt</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/422/pycon-2011--units-need-testing-too</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/422_units-need-testing-too.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011UnitsNeedTestingToo863.png"></media:thumbnail></item><item><title>Useful Namespaces: Context Managers and Decorators</title><link>http://www.pyvideo.org/video/395/pycon-2011--useful-namespaces--context-managers-a</link><description>&lt;p&gt;Description&lt;/p&gt;
Useful Namespaces: Context Managers and Decorators

Presented by Jack Diederich

Python has two useful conventions for "I mean it, but only here" and you can
say it with Context Managers and Decorators. Both give you the power to define
a push/pop of a resource for a set period inside a namespace, be it a function
or a level of indentation. This talk is a list of patterns that are
implemented by one or the other (including some clever functions that are
both).

Abstract

  * Decorators, formal definition. 
  * Context Managers, formal definition. 
  * Informal definition: both have the opportunity to do and then undo. - very similar to C++ RIIA "Resource Acquisition Is Initialization." - Context Managers were designed to do that but decorators are frequently just as good. 
  * Which one to use use when is all about namespaces. - Context Managers manipulate at the block level. - Function Decorators manipulate the function level. - Class Decorators manipulate at the class level. 
  * Recipes on writing decorators and context managers - Familiar examples from Django and Mock. 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jack Diederich</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/395/pycon-2011--useful-namespaces--context-managers-a</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/395_useful-namespaces-context-managers-and-decorators.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011UsefulNamespacesContextManagersAndDecorators353.png"></media:thumbnail></item><item><title>Using Blender's new BPY Python API</title><link>http://www.pyvideo.org/video/411/pycon-2011--using-blender--39-s-new-bpy-python-ap</link><description>&lt;p&gt;Abstract&lt;/p&gt;
Blender 2.5 (a free and open source software 3d graphics suite) includes a new
BPY python API which is usable for scripting modeling, animation, etc. Learn
to use this API to speed up your workflow, create procedural graphics, and
cool new tools.


&lt;p&gt;Description&lt;/p&gt;
Since 2.5, the API has become more pythonic and self-descriptive. Blender's UI
can show you the Python equivalent for nearly every user action and includes a
full datablock exploration tool. Users will be taught how to use so they can
quickly adapt to their appropriate needs with a little Blender experience and
no previous BPY experience.

There will be a brief Blender overview, an introduction to the API and how to
use it, as well as / along with an overview of some of the presenter's own
tools / use cases. Some other popular 3rd party Python tools will also be
shown as an example.

If there is time, a brief demo of the Blender Game Engine will also be given,
though that is a separate API.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Christopher Allan Webber</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/411/pycon-2011--using-blender--39-s-new-bpy-python-ap</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/411_using-blender-s-new-bpy-python-api.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011UsingBlendersNewBPYPythonAPI450.png"></media:thumbnail></item><item><title>Using Coroutines to Create Efficient, High-Concurrency Web Applications</title><link>http://www.pyvideo.org/video/377/pycon-2011--using-coroutines-to-create-efficient-</link><description>&lt;p&gt;Description&lt;/p&gt;
Using Coroutines to Create Efficient, High-Concurrency Web Applications

Presented by Matt Spitz

Creating high-concurrency python web applications is inherently difficult for
a variety of reasons. In this talk, I'll discuss the various iterations of
application server paradigms we've used at meebo, the advantages/disadvantages
of each approach, and why we've settled on a coroutine-based WSGI setup to
handle our high-concurrency web applications going forward.

Abstract

There are a number of ways in which to create a web application in python.
Some examples include a straight-up CGI scripts that run anew with each
request, preforked Apache workers that each handle multiple requests, and
using an asynchronous web framework like Twisted.

At meebo, we've settled on using gunicorn, a lightweight WSGI server, which
supports gevent, a coroutine-based network library for python. Gevent
monkeypatches python's system modules to make network requests asynchronous
using an event loop based on libevent. This trick allows the developer to use
a simple blocking CGI as a non-blocking web application that can handle many
concurrent requests.

I'll discuss our iteration process through these approaches to building web
applications, why we ended up choosing gunicorn+gevent, the challenges this
new framework presents, and how we've dealt with them.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Matt Spitz</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/377/pycon-2011--using-coroutines-to-create-efficient-</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/377_using-coroutines-to-create-efficient-high-concurrency-web-applications.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011UsingCoroutinesToCreateEfficientHighConcurrency731.png"></media:thumbnail></item><item><title>Using Python 3 to Build a Cloud Computing Service for my Superboard II</title><link>http://www.pyvideo.org/video/443/pycon-2011--using-python-3-to-build-a-cloud-compu</link><description>&lt;p&gt;Description&lt;/p&gt;
Using Python 3 to Build a Cloud Computing Service for my Superboard II

Presented by David Beazley

The OSI Superboard II was the computer on which I first learned to program
back in 1979. Python is why programming remains fun today. In this tale of old
meets new, I describe how I have used Python 3 to create a cloud computing
service for my still-working Superboard--a problem complicated by it only
having 8Kb of RAM and 300-baud cassette tape audio ports for I/O.

Abstract

Python 3, what good is it? Cloud computing? Bah! In this talk, I describe how
I have used Python 3 to build a distributed cloud-computing service for my
Superboard II system. Originally built in 1978, the Superboard is an obvious
candidate for cloud computing due to its extremely constrained memory (8Kb),
slow processor (a 1Mhz 6502), crippled I/O (300 baud over audio), and retro
programming environment (Microsoft Basic 1.0). The only question is how to do
it?

To answer that question, this talk consist of two main parts. In the first
part, I discuss the problem of building a communications stack between the
Superboard and a Mac using nothing but audio line-in/line-out ports--a problem
involving a tricky I/O handling, real-time audio signal processing, and the
creation of a data-link layer communication protocol. In the second part, I
discuss the creation of a distributed cloud-computing service and related
topics including messaging systems, key-value stores, map-reduce, etc.

The primary implementation language for all of this work is Python 3.
Throughout the talk, I will mention interesting Python 3 programming idioms
along with pros and cons. I'll conclude by summarizing my experience trying to
build a significant project entirely in Python 3.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Beazley</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/443/pycon-2011--using-python-3-to-build-a-cloud-compu</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/443_using-python-3-to-build-a-cloud-computing-service-for-my-superboard-ii.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011UsingPython3ToBuildACloudComputingServiceFor438.png"></media:thumbnail></item><item><title>web2py secrets tutorial (1/2)</title><link>http://www.pyvideo.org/video/433/pycon-2011--web2py-secrets-tutorial--1-2</link><description>&lt;p&gt;Description&lt;/p&gt;
web2py secrets

Presented by Massimo Di Pierro

We will provide an introduction to web2py with particular focus on its design
objectives, its differences when compared to other web frameworks, and some of
the most recently added features (components, plugins, openid/oauth
integration).

Abstract

Web2py is a framework for rapid web application development of secure
database-driven web applications. In this tutorial we will provide a brief
introduction to web2py, the web based IDE, its internal design, and its
internal file organization. We will explain the motivations behind some of its
most controversial design goals. We will also discuss in some detail its Ajax
capabilities by using web2py components and plugins for modular design of rich
web interfaces.

This will be a very concentrated version (10%) of a course (CSC438) on web
frameworks the author teaches at DePaul University. The course has been taught
3 times and the last time counted more than 30 students.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Massimo Di Pierro</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/433/pycon-2011--web2py-secrets-tutorial--1-2</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/433_web2py-secrets-tutorial-1-2.m4v" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Mdipierro-web2pyTutorialPycon201112623-523.jpg"></media:thumbnail></item><item><title>What would you do with an ast?</title><link>http://www.pyvideo.org/video/419/pycon-2011--what-would-you-do-with-an-ast</link><description>&lt;p&gt;Description&lt;/p&gt;
What would you do with an ast?

Presented by Matthew J Desmarais

The ast module in the Python (&gt;= 2.6) standard library provides a
representation of python code in a python data structure. We'll begin with a
discussion about what an abstract syntax tree is and why it's useful. We can
then talk about what's available in the ast module, how it works, and how you
can use it. This will be a practical session built around examples examining
and modifying live ASTs.

Abstract

I would prefer to make this a 45 minute talk with examination of code samples.

Python 2.6 introduced a new module in the standard library, ast. The first
line of the ast documentation is, "The ast module helps Python applications to
process trees of the Python abstract syntax grammar." What this means is not
obvious and many, if not most, python programmers won't know what this means.
I will begin by talking about the idea of syntax tree and how it fits into the
python execution lifecycle. I will also talk about the contents of the ast
module. I will cover the available ast.Node subclasses and the provided helper
functions, including the NodeVisitor and NodeTransformer. I will finish by
talking about how the ast module can be used to analyze Python code and how it
can be used to generate new code.

I expect the time to break down roughly like this:

Introduction ( 5m )

  * Capacitor joke 
  * What is an abstract syntax tree? 
  * How they are used by the Python interpreter 

The contents of the ast module (20 m)

  * The node subclasses and the ast ( 10m ) 
    * How you get an ast. 
      * code examples
    * ast.stmt vs. ast.expr 
    * peculiarities 
      * code examples 
        * elif as syntactic sugar for "if: else: if:" 
        * comparison operators 
    * Why this is useful. 
      * the ast is the "truth" of the program 
        * code examples 
        * tricky code 
  * The ast module helpers ( 10m ) 
    * visitor pattern 
    * NodeVisitor 
    * NodeTransformer 
    * code examples 

What you do with an ast ( 15m )

  * Walking an ast 
    * code examples 
      * a simple visitor to gather variables by scope
  * Creating/Modifying an ast 
    * code examples 
      * rearrange imports transformer 
      * naive "rename all instances" transformer 
      * naive macro expansion transformer 

Conclusion ( 5m )

  * Practical Applications 
    * existing projects 
      * visitors 
        * checkers (pylint, pyflakes)
      * transformers 
        * refactoring tools (rope)
  * When is it a good idea to use ast? 

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Matthew J Desmarais</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/419/pycon-2011--what-would-you-do-with-an-ast</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/419_what-would-you-do-with-an-ast.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011WhatWouldYouDoWithAnAst198.png"></media:thumbnail></item><item><title>Why is Python slow and how PyPy can help?</title><link>http://www.pyvideo.org/video/427/pycon-2011--why-is-python-slow-and-how-pypy-can-h</link><description>&lt;p&gt;Description&lt;/p&gt;
Why is Python slow and how PyPy can help?

Presented by Maciej Fijalkowski and Alex Gaynor

PyPy is a virtual machine for Python, featuring an advanced just in time
compiler, which can deliver exceptional performance. This talk is going to be
a deep dive into what exactly makes Python such a hard language to optimize,
how PyPy is organized, and what optimizations our JIT can do (and what it
can't do) for your code.

Abstract

The talk will detail how a python interpreter works internally and why some
operations are costly. We'll go through several python features, how they
work, why they're slow in CPython and how we're fixing it.

The list of mentioned features is not exhaustive, however we will try to focus
at least on the following:

  * Dynamic language - In Python code we have no known types, like a statically typed language. Even operations like "a + b" can do anything, unless we know more about the code, and the types it is operating on.

  * Frame introspection - Frame objects need to be allocated for every function call, and all local variables are stored on the frame, and must be accessible from further down the call stack.

PyPy uses a novel approach called "virtualizables" which makes it possible to
avoid frame allocation in most common cases.

  * Object model - All user defined Python objects have a dictionary which stores their attributes, as does every type. When Python does an attribute lookup this requires at least two dictionary lookups.

In PyPy we use an approach similar to the one used by V8 with hidden classes
(except more PyPy specific) called map dictionaries and other optimizations.

  * FFI calls - Calling C from Python is costly and hard to optimize. In PyPy we expose C APIs to Python code via ctypes. This part explains how we can optimize ctypes calls.

  * array module - Users of CPython's array module probably know it can save them quite a bit of memory, however it's also slower than using a list, due to the overhead of boxing and unboxing on every operations. Here we will tie everything together and describe how the array module is much faster with PyPy's JIT, combining our optimizations to: unbox values, remove the dynamicism within traces, and deliver great performance.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Gaynor,Maciej Fijalkowski</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/427/pycon-2011--why-is-python-slow-and-how-pypy-can-h</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/427_why-is-python-slow-and-how-pypy-can-help.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011WhyIsPythonSlowAndHowPyPyCanHelp525.png"></media:thumbnail></item><item><title>Writing Command-Line Tools using IronPython and Visual Studios</title><link>http://www.pyvideo.org/video/368/pycon-2011--writing-command-line-tools-using-iron</link><description>&lt;p&gt;Abstract&lt;/p&gt;
Learn how cool it is to write command-line tools using IronPython and Visual
Studios. In this talk we cover why command-lines tools are important for .NET
shops, how to write one, and finally, how to distribute it as a standalone
.exe.


&lt;p&gt;Description&lt;/p&gt;
Learn how cool it is to write command-line tools using IronPython and Visual
Studios. In this talk we cover why command-lines tools are important for .NET
shops, how to write one, and finally, how to distribute it as a standalone
.exe.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Noah Gift</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/368/pycon-2011--writing-command-line-tools-using-iron</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/368_writing-command-line-tools-using-ironpython-and-visual-studios.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011WritingCommandLineToolsUsingIronPythonAndVisual529-639.jpg"></media:thumbnail></item><item><title>Writing great documentation</title><link>http://www.pyvideo.org/video/403/pycon-2011--writing-great-documentation</link><description>&lt;p&gt;Description&lt;/p&gt;
Writing great documentation

Presented by Jacob Kaplan-Moss

Django’s among the best documented open source projects; I'm intensely proud
of that accomplishment. If any part of Django endures, I hope it’ll be a
“documentation culture” — an ethos that values great, well-written
documentation. To that end, this talk looks at the tools, tips, and techniques
I’ve learned over the years. I hope it helps you write great documentation,
too.

Abstract

This talk looks at tips, tools, and techniques you can use to produce great
technical documentation.

It's split roughly into two parts:

  * Part 1: technique. We'll look at the structural elements that make documentation useful: tutorials, high-level overviews, topical guides, reference material, FAQs, and more. We'll cover some tips on how to get documentation done, and community processes for handling documentation in teams (open or not). We'll also talk about what I'm calling "Documentation Driven Development" - a technique riffing off Test Driven Development that calls for writing documentation before code. 
  * Part 2: tools. Over the last couple of years a few fantastic tools have sprung up that ease the technical aspects of writing documentation. We'll talk about which tools are suitable for which uses, and look at a handful of cool tools including [Sphinx](http://sphinx.pocoo.org/), [Epydoc](http://epydoc.sourceforge.net/), and [http://fitzgen.github.com/pycco/](http://fitzgen.github.com/pycco/). 

This talk is mostly targeted towards those documenting libraries or frameworks
intended for use by other developers, but much of it probably applies to any
sort of technical documentation.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jacob Kaplan-Moss</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/403/pycon-2011--writing-great-documentation</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/403_writing-great-documentation.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011WritingGreatDocumentation902.png"></media:thumbnail></item><item><title>ZODB: A Python Persistence System</title><link>http://www.pyvideo.org/video/430/pycon-2011--zodb--a-python-persistence-system</link><description>&lt;p&gt;Description&lt;/p&gt;
ZODB: A Python Persistence System

Presented by Chris McDonough

[ZODB](http://zodb.org/) is a transactional persistence system written
entirely in Python. This talk will serve as an introduction to using the ZODB
in a Python application.

Abstract

This talk will provide a high-level overview of ZODB useful to a novice or
intermediate Python programmer. The talk will cover the following topics:

  * What Is ZODB? 
  * Brief history 
  * ZODB vs. relational databases 
  * ZODB vs. NoSQL databases 
  * ZODB vs. pickle 
  * Using ZODB 
  * Creating a Persistent Object 
  * Storing a Persistent Object 
  * Retrieving a Persistent Object 
  * Modifying a Persistent Object 
  * Saving Changes 
  * Folders 
  * Aspects 
  * Pluggable storages 
  * Scaling across multiple clients 
  * Caching 
  * Indexing and Searching 
  * repoze.catalog 

At the end of the talk, an attendee should have a basic understanding of how
to create an application which depends on ZODB persistence.

</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris McDonough</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 -0600</pubDate><guid>http://www.pyvideo.org/video/430/pycon-2011--zodb--a-python-persistence-system</guid><enclosure url="http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/430_zodb-a-python-persistence-system.mp4" length="None" type="video/mp4"></enclosure><media:thumbnail url="http://a.images.blip.tv/Pycon-PyCon2011ZODBAPythonPersistenceSystem382.png"></media:thumbnail></item></channel></rss>